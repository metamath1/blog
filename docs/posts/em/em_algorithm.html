<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jo, Joonu (metamath@gmail.com)">
<meta name="dcterms.date" content="2020-07-09">

<title>ML simple works - A Step by Step Introduction to EM Algorithm</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">ML simple works</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page">
      <h1 class="title">A Step by Step Introduction to EM Algorithm</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">ai</div>
                <div class="quarto-category">em algorithm</div>
                <div class="quarto-category">machine learning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jo, Joonu (metamath@gmail.com) </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 9, 2020</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block column-page" id="quarto-document-content">




<section id="em-알고리즘-완전분석-a-step-by-step-introduction-to-em-algorithm" class="level1">
<h1>EM 알고리즘 완전분석 A Step by Step Introduction to EM Algorithm</h1>
<hr>
</section>
<section id="em-알고리즘---1편" class="level1">
<h1>EM 알고리즘 - 1편</h1>
<section id="본-글의-목적" class="level2">
<h2 class="anchored" data-anchor-id="본-글의-목적">본 글의 목적</h2>
<p>머신러닝을 공부하다 보면 한번은 보게되는 알고리즘이 바로 EM 알고리즘이다. 많은 문헌에서 이 알고리즘을 설명할 때 K-평균 군집화로 시작해서 가우시안 혼합으로 끝을 맺는다. 하지만 두 알고리즘에 대해서 설명하는 것은 EM 알고리즘의 적용 예를 설명하는 것이지 EM 알고리즘을 근본적으로 이해하기 위한 논리를 설명하는 것이 아니어서 해당 내용을 모두 읽어봐도 EM 알고리즘이 도대체 무엇인지 감을 잡기 힘든 경우가 대부분이다.</p>
<p>EM 알고리즘에 대해서 자세한 설명이 부족하게 된 원인은 개인적인 견해지만 EM 알고리즘이 확률과 통계를 기반으로 하는 알고리즘이기 때문이라 생각한다. 확률과 통계는 알아야 할 내용도 많고 매우 추상적이기 때문에 (적어도 나에게는) 기본적으로 쉽게 접근할 수 없는 문제가 있다. 그런데 그런 내용들이 복잡하게 얽혀 있다면 지면의 한계 또는 난이도의 제약으로 충분한 설명을 하지 못하는 것이 어쩌면 당연할 수도 있다는 생각이 든다.</p>
<p>이는 관련 분야 전공자들도 어느정도 인정하는 부분인데(https://bayestour.github.io/blog/2019/06/23/EM_algorithm.html) 이런 어려움은 정식으로 출판된 문헌에서도 확인할 수 있다. “The Elements of Statistical Learning”을 예로 들면 EM 알고리즘을 설명하는 8.5절에 뭉크의 절규 아이콘이 붙어 있다.</p>
<p>확률, 통계에 대한 초보적 지식을 가진 공대생이 참고할 만한 좋은 책은 “패턴인식과 머신러닝”(이하 PRML로 표기)인데 9장 전체를 할애하여 EM 알고리즘을 설명하고 있다. 그런데 이 교재 역시 내용을 전개하는 순서가 좋지 못해서 전체적인 맥락을 이해하기 매우 힘들다.</p>
<p>이런 이유로 이 글은 PRML의 설명을 재구성하여 가능한 쉬운 예와 코드를 곁들여 EM 알고리즘을 이해하는 것을 목적으로 한다. 그렇기 때문에 수식 번호와 기호법은 PRML과 동일하게 구성하였다. 수식 번호에 (x.x)형식은 PRML 수식을 그대로 사용한 것이다. 혹시나 이 글을 읽고 PRML을 다시 읽을 때 혼란을 최소화 하기 위해서이다.</p>
<p>가급적 쉽게 설명하려고 많은 고민을 하였으나 기본적으로 이 글을 읽기 위한 선수 지식이 있음을 피할 수는 없었다. 이 글을 읽기 위한 선수 지식은 다음과 같다.</p>
<ul>
<li><p>이항분포</p></li>
<li><p>가능도 함수</p></li>
<li><p>경사 하강법</p></li>
<li><p>최대 가능도 추정MLE:Maximum Likelihood Estimation</p></li>
<li><p>라그랑지 승수와 간단한 제약 최적화</p></li>
<li><p>python 문법과 <code>scipy.optimize.minimize()</code> 함수 사용법</p></li>
</ul>
<p>(선수 지식이 이 정도인데 이 글 정말 쉽게 이해할 수 있는 글 맞는건지?? ;;;)</p>
<p>아래 코랩 링크를 눌러 코랩에서 직접 실행하면서 글을 읽을 수 있다.</p>
<p><a href="https://colab.research.google.com/github/metamath1/ml-simple-works/blob/master/EM/em_algorithm.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a></p>
</section>
<section id="기호" class="level2">
<h2 class="anchored" data-anchor-id="기호">기호</h2>
<p>다음에 이 글 전반에 걸쳐 사용하는 기호를 정리하였다.</p>
<ul>
<li><span class="math inline">\(x\)</span>, <span class="math inline">\(\mathbf{x}\)</span> : <span class="math inline">\(D\)</span>차원 벡터인 데이터, 스칼라인 경우 <span class="math inline">\(D=1\)</span></li>
<li><span class="math inline">\(N\)</span> : 데이터 <span class="math inline">\(\mathbf{x}\)</span>의 개수</li>
<li><span class="math inline">\(N_k\)</span> : <span class="math inline">\(k\)</span>번째 분포에서 샘플링된 데이터 개수</li>
<li><span class="math inline">\(\mathbf{X}\)</span> : 데이터 <span class="math inline">\(\mathbf{x}_n\)</span>이 행인 행렬. 차원은 <code>(N,D)</code></li>
<li><span class="math inline">\(K\)</span> : 데이터를 샘플링한 분포의 개수</li>
<li><span class="math inline">\(\mathbf{z}\)</span> : <span class="math inline">\(K\)</span>차원 벡터인 잠재변수, 이 잠재변수는 원핫인코딩된 다항변수이다.</li>
<li><span class="math inline">\(\mathbf{Z}\)</span> : 잠재변수 <span class="math inline">\(\mathbf{z}_n\)</span>이 행인 행렬. 차원은 <code>(N,K)</code></li>
<li><span class="math inline">\(n_t\)</span> : 이항분포에서 시도 횟수</li>
</ul>
</section>
<section id="문제-설정" class="level2">
<h2 class="anchored" data-anchor-id="문제-설정">문제 설정</h2>
<p>본격적인 설명을 하기 앞서 EM알고리즘을 개략적으로 설명한 다음 글을 읽어보길 추천한다.</p>
<blockquote class="blockquote">
<p>“박준석, 2019, EM 알고리즘 이해 및 구현하기”(https://bayestour.github.io/blog/2019/06/23/EM_algorithm.html)</p>
</blockquote>
<p>간단하게 문제를 설정하고 매우 직관적으로 EM알고리즘을 설명하는 좋은 글이다. EM 알고리즘에 대해 어느 정도 이해를 하고 있는 것 같은데 깔끔하게 정리가 안되는 느낌을 가지고 있다면 꼭 한번 읽어보길 추천한다.</p>
<p>본 글에서는 윗 글에서 다루고 있는 똑같은 사례에 좀 더 자세한 설명을 추가하는 것으로 논의를 시작하고자 한다. 박준석(2019)의 원문격에 해당하는 논문(https://www.nature.com/articles/nbt1406?proof=true) 에서는 베르누이 확률분포를 따르는 동전을 한 세트에 열번씩 다섯 세트 던지는 상황을 이야기 하고 있다. 이것을 박준석(2019)에서는 <span class="math inline">\(n_t=10\)</span>인 이항분포에서 다섯 번 샘플링하는 방식으로 이야기하고 있다. 본 글에서도 후자를 기준으로 하며 그 문제는 다음과 같다.</p>
<blockquote class="blockquote">
<p><span class="math inline">\(\text{Bin}(x \mid n_t =10, \mu_1)\)</span>과 <span class="math inline">\(\text{Bin}(x \mid n_t=10, \mu_2)\)</span>인 이항분포 두 개가 있다. 두 분포로 부터 독립적으로 다섯 번 샘플링을 하는데 (10, 4, 3, 7, 8)처럼 샘플링이 되었다. 이 정보를 가지고 <span class="math inline">\(\mu_1\)</span>, <span class="math inline">\(\mu_2\)</span>를 추정하시오.</p>
</blockquote>
<p>이 상황을 코드로 구현하면 다음과 같다.</p>
<div class="cell" data-outputid="3f57ed23-a720-47d6-9b50-bcbff06606ac">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 글 전체에서 필요한 모듈을 임포트한다.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 구글 코랩에서 그래프에 LaTeX를 원활히 쓰기 위한 설정으로 코랩이 아니면 실행 안함</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>matplotlib.rc(<span class="st">'text'</span>, usetex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>matplotlib.rcParams[<span class="st">'text.latex.preamble'</span>] <span class="op">=</span> [<span class="vs">r'\usepackage</span><span class="sc">{amsmath}</span><span class="vs">'</span>]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>apt install texlive<span class="op">-</span>fonts<span class="op">-</span>recommended texlive<span class="op">-</span>fonts<span class="op">-</span>extra cm<span class="op">-</span><span class="bu">super</span> dvipng <span class="op">&gt;</span> <span class="op">/</span>dev<span class="op">/</span>null</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

Extracting templates from packages: 100%</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 두 이항분포의 알지 못하는 파라미터</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>MU_1, MU_2 <span class="op">=</span> <span class="fl">0.8</span>, <span class="fl">0.45</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 이항분포에서 시행횟수 n_t</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>n_t <span class="op">=</span> <span class="dv">10</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-outputid="74ff9dd1-558a-4a22-8c7a-ce9ec2119ed3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 샘플링</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">1</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 적당히 샘플링하고</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>x_from_p1 <span class="op">=</span> np.random.binomial(n_t, MU_1, <span class="dv">3</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>x_from_p2 <span class="op">=</span> np.random.binomial(n_t, MU_2, <span class="dv">2</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 섞어서 X를 만든다.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.concatenate((x_from_p1, x_from_p2))</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>np.random.shuffle(X)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[10  4  3  7  8]</code></pre>
</div>
</div>
<p>여기서 우리가 하고자 하는 것은 데이터 (10, 4, 3, 7, 8)을 이용하여 두 분포의 파라미터 <span class="math inline">\(\mu_1\)</span>과 <span class="math inline">\(\mu_2\)</span>를 추정하는 것이다. 위 코드에서 <span class="math inline">\(\mu_1=0.8\)</span>, <span class="math inline">\(\mu_2=0.45\)</span>로 둔 것이 확인되지만 원래 이 숫자는 우리가 추정해야 하는 것이다.</p>
<p>만약 샘플 다섯 개가 분포 하나로 부터 나온 간단한 경우라면 분포의 파라미터를 추정하기 위해 데이터에 대한 최대 가능도 추정을 하면 된다. 하지만 샘플링하는 분포는 두 개이며 어느 분포에서 어떤 데이터가 샘플링되었는지 모르는 상황이다. 따라서 데이터에 대한 가능도 함숫값을 계산할 수 가 없다. 각 데이터가 어느 분포에서 샘플링되었는지 알고 있다면 각 분표별로 데이터를 나누고 각각 최대 가능도 추정을 하면 될것이다. 결국 위 상황에 대해서 모든 정보를 다 알고 있다고 말할 수 있으려면 샘플링된 숫자 다섯 개가 어느 분포에서 샘플링되었는지도 알아야 한다.</p>
<p>샘플링된 데이터를 <span class="math inline">\(x_n\)</span>으로 쓰기로 하자. 그리고 <span class="math inline">\(x_n\)</span>이 어느 분포에서 생성되었는지를 나타내는 카테고리 변수를 <span class="math inline">\(\mathbf{z}_n\)</span>으로 쓰기로 하자. 앞서 말한 것처럼 모든 정보를 다 알고 있다고 하려면 <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span>, <span class="math inline">\(x_3\)</span>, <span class="math inline">\(x_4\)</span>, <span class="math inline">\(x_5\)</span>와 이에 해당하는 <span class="math inline">\(\mathbf{z}_1\)</span>, <span class="math inline">\(\mathbf{z}_2\)</span>, <span class="math inline">\(\mathbf{z}_3\)</span>, <span class="math inline">\(\mathbf{z}_4\)</span>, <span class="math inline">\(\mathbf{z}_5\)</span>도 모두 알아야 한다. 우리가 가진 데이터가 1번 분포, 2번 분포, 2번 분포, 1번 분포, 1번 분포에서 생성되었다면 <span class="math inline">\(\mathbf{z}_n\)</span>은 각각 다음과 같을 것이다.</p>
<p><span class="math display">\[
\mathbf{z}_1 = (1, 0)^\text{T} \\
\mathbf{z}_2 = (0, 1)^\text{T} \\
\mathbf{z}_3 = (0, 1)^\text{T} \\
\mathbf{z}_4 = (1, 0)^\text{T} \\
\mathbf{z}_5 = (1, 0)^\text{T}
\]</span></p>
<p>이제 <span class="math inline">\(x_n\)</span>, <span class="math inline">\(\mathbf{z}_n\)</span>을 모두 모아 행렬 <span class="math inline">\(\mathbf{X}\)</span>, <span class="math inline">\(\mathbf{Z}\)</span>로 표기하자. 행렬 <span class="math inline">\(\mathbf{X}\)</span>에서 한 행은 <span class="math inline">\(x_n\)</span>인데 만약 샘플링되는 데이터가 벡터라면 <span class="math inline">\(\mathbf{x}_n^{\text{T}}\)</span>가 될 것이다. 행렬 <span class="math inline">\(\mathbf{Z}\)</span>에서 한 행은 <span class="math inline">\(\mathbf{z}_n^{\text{T}}\)</span>이다. 행렬 <span class="math inline">\(\mathbf{X}\)</span>와 <span class="math inline">\(\mathbf{Z}\)</span>는 다음과 같게 된다.</p>
<p><span class="math display">\[
\mathbf{X} = \begin{bmatrix}
x_1 \\
x_2 \\
x_3 \\
x_4 \\
x_5
\end{bmatrix}= \begin{bmatrix}
10\\ 4\\ 3\\ 7\\ 8
\end{bmatrix} \qquad
\mathbf{Z} = \begin{bmatrix}
\mathbf{z}_1^{\text{T}} \\
\mathbf{z}_2^{\text{T}} \\
\mathbf{z}_3^{\text{T}} \\
\mathbf{z}_4^{\text{T}} \\
\mathbf{z}_5^{\text{T}}
\end{bmatrix}=\begin{bmatrix}
1 &amp; 0 \\ 0 &amp; 1 \\ 0 &amp; 1 \\ 1 &amp; 0 \\ 1 &amp; 0
\end{bmatrix}
\]</span></p>
<p>간단하게 아래 코드로 행렬 <span class="math inline">\(\mathbf{X}\)</span>, <span class="math inline">\(\mathbf{Z}\)</span>를 만들어 두자.</p>
<div class="cell" data-outputid="796f4fc2-cf3c-41e1-f0ce-65b49653721c">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># X: (N,D), (5,1)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> X.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(X)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Z: (N,K), (5,2)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>]])</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Z)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 노트북 전체에 사용될 전역 변수 설정</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>N, D <span class="op">=</span> X.shape</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[10]
 [ 4]
 [ 3]
 [ 7]
 [ 8]]
[[1 0]
 [0 1]
 [0 1]
 [1 0]
 [1 0]]</code></pre>
</div>
</div>
<p>이렇게 두 행렬 <span class="math inline">\(\{\mathbf{X}, \mathbf{Z}\}\)</span>가 모두 주어지는 데이터를 완전 데이터 세트complete data set라 한다. 완전 데이터 세트일 때 최대 가능도 추정을 실제로 해보자.</p>
</section>
<section id="완전-데이터-세트에-대한-최대-가능도-추정" class="level2">
<h2 class="anchored" data-anchor-id="완전-데이터-세트에-대한-최대-가능도-추정">완전 데이터 세트에 대한 최대 가능도 추정</h2>
<section id="가능도-함수" class="level3">
<h3 class="anchored" data-anchor-id="가능도-함수">가능도 함수</h3>
<p>문제 설정에서 주어진 문제는 확률분포가 2개인 경우지만 <span class="math inline">\(K\)</span>개로 가정하고 이야기하자. 주어진 <span class="math inline">\(K\)</span>개 분포중 특정 <span class="math inline">\(k\)</span>번째 분포가 선택될 확률을 <span class="math inline">\(\pi_k\)</span>로 표시하자. 그러면 어떤 샘플 <span class="math inline">\(x\)</span>에 대한 확률질량함수는 다음처럼 주어진 확률분포함수를 선형조합하여 얻을 수 있을 것이다. 이때 선형조합 계수는 <span class="math inline">\(\pi_k\)</span>가 될 것이다.</p>
<p><span class="math display">\[
p(x)  = \sum_{k=1}^K \pi_k \text{Bin}(x \mid n_t, \mu_k) \tag{9.7}
\]</span></p>
<p>직관적으로 식(9.7)이 맞을 것 같지만 정말 그렇게 되는지는 불완전 데이터 세트에 대한 가능도 함수를 구할 때 다시 정식으로 유도해보자.</p>
<p>앞서 살펴봤듯이 <span class="math inline">\(x\)</span>가 어떤 분포에서 샘플링 되었는지를 나타내는 잠재변수latent variable <span class="math inline">\(\mathbf{z}\)</span>는 <span class="math inline">\(K\)</span>차원 멀티누이multinoulli 변수이다. 따라서 변수 <span class="math inline">\(\mathbf{z}\)</span>의 확률질량함수는 식(9.10)처럼 쓸 수 있다.</p>
<p><span class="math display">\[
p(\mathbf{z}) = \prod_{k=1}^{K} \pi_k^{z_k} \tag{9.10}
\]</span></p>
<p><span class="math inline">\(\mathbf{z}\)</span>가 주어졌다면 샘플 <span class="math inline">\(x\)</span>가 어느 분포를 따르는지 알 수 있으므로 해당 샘플의 확률분포 함수는 그 <span class="math inline">\(\mathbf{z}\)</span>가 가리키는 분포의 <span class="math inline">\(\text{Bin}(x \mid n_t, \mu_k)\)</span>가 된다. 다시말해 <span class="math inline">\(\mathbf{z}\)</span>가 주어진 조건하에서 <span class="math inline">\(x\)</span>의 확률분포 함수는 식(9.11)처럼 결정되게 된다.</p>
<p><span class="math display">\[
p(x \mid \mathbf{z}) = \prod_{k=1}^K \text{Bin}(x \mid n_t, \mu_k)^{z_k} \tag{9.11}
\]</span></p>
<p><span class="math inline">\(\mathbf{z}\)</span>에서 <span class="math inline">\(z_k\)</span>는 오직 하나만 1이고 나머지는 0이므로 잘 생각해보면 식(9.11)이 타당함을 알 수 있다. 이제 <span class="math inline">\(x\)</span>와 <span class="math inline">\(\mathbf{z}\)</span>의 결합확률분포를 생각하자.</p>
<p><span class="math display">\[
p(x,\mathbf{z}) = p(x \mid \mathbf{z})p(\mathbf{z}) = \prod_{k=1}^K \pi_k^{z_k} \text{Bin}(x \mid n_t, \mu_k)^{z_k}
\]</span></p>
<p>파라미터를 <span class="math inline">\(\boldsymbol{\theta}=(\pi_1, \pi_2, ..., \pi_k, \mu_1, \mu_2, ..., \mu_k)^{\text{T}}\)</span>로 쓰면 완전 데이터 세트의 <span class="math inline">\(\boldsymbol{\theta}\)</span>에 대한 가능도 함수는 다음과 같다.</p>
<p><span class="math display">\[
p(x,\mathbf{z} \mid \boldsymbol{\theta}) = \prod_{k=1}^K \pi_k^{z_k} \text{Bin}(x \mid n_t, \mu_k)^{z_k}
\]</span></p>
<p>모든 데이터를 고려하기 위해 데이터에 대한 인덱스 <span class="math inline">\(n\)</span>을 도입하고 독립성 가정하에서 가능도를 구하기 위해 모두 곱해주자.</p>
<p><span class="math display">\[
p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta}) = \prod_{n=1}^N \prod_{k=1}^K \pi_k^{z_{nk}} \text{Bin}(x_n \mid n_t, \mu_k)^{z_{nk}}
\]</span></p>
<p>이제 가능도 함수에 로그를 적용하면 최종적으로 완전 데이터 세트에서 로그 가능도 함수가 구해진다.</p>
<p><span class="math display">\[
\ln p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta}) = \sum_{n=1}^N \sum_{k=1}^K z_{nk} \{ \ln \pi_k + \ln \text{Bin}(x_n \mid  n_t, \mu_k) \} \tag{9.36}
\]</span></p>
<p>식(9.36)에서 <span class="math inline">\(z_{nk}\)</span>를 모두 알고 있으므로 로그 가능도함수의 함숫값을 실제로 구할 수 있고 이를 이용하여 수지척으로 식(9.36)을 최적화 할 수 있다.</p>
</section>
<section id="수치적-방법" class="level3">
<h3 class="anchored" data-anchor-id="수치적-방법">수치적 방법</h3>
<p>가능도 함수를 구했으므로 이 가능도 함수를 기울기 하강법을 이용하여 직접 최적화 시켜볼 수 있다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> binom</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize, Bounds</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>식(9.36)을 목적함수로 설정하고 나머지 최적화 과정은 사이파이 최적화 함수를 쓰기로 하자. 위처럼 필요한 모듈을 임포트 한다. 결정해야하는 변수는 <span class="math inline">\(\mu_1\)</span>, <span class="math inline">\(\mu_2\)</span>, <span class="math inline">\(\pi_1\)</span>, <span class="math inline">\(\pi_2\)</span>이고 초기값은 적당히 초기화 한다.</p>
<div class="cell" data-outputid="97f351e7-bd63-4020-9595-e2b0e594176c">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 초기 파라미터를 주어진 데이터 중에서 아무거나 골라 만든다.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">34</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>mu_0 <span class="op">=</span> X[np.random.choice(N, K)] <span class="op">/</span> n_t</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># pi는 동일하게 설정한다.</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>pi_0 <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="fl">0.5</span>])</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mu_0)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pi_0)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0.4]
 [0.3]]
[0.5 0.5]</code></pre>
</div>
</div>
<p>이제 식(9.36)을 그대로 코딩한다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loglikelihood_XZ_(mu, pi, X, Z):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">    eq(9.36)</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">    mu     : (K,D)</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">    pi     : (K,)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">    X      : (N,D) global variable</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Z      : (N,K)</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------------------------------------</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">    N,D,K : gloval variables</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># N, D, K = X.shape[0], X.shape[1], Z.shape[1]</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    sigma_n <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        sigma_k <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(K):</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            loglikelihood_x <span class="op">=</span> np.log(binom.pmf(X[n,<span class="dv">0</span>], n_t, mu[k,<span class="dv">0</span>])<span class="op">+</span><span class="fl">1.0e-8</span>)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>            sigma_k <span class="op">+=</span> Z[n,k] <span class="op">*</span> (np.log(pi[k]<span class="op">+</span><span class="fl">1.0e-8</span>) <span class="op">+</span> loglikelihood_x)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        sigma_n <span class="op">+=</span> sigma_k</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sigma_n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>scipy.optimize.minimize()</code>함수를 사용하기 위해서는 최적화 변수가 1차원 벡터 형식으로 전달되어야 한다. 위 <code>loglikelihood_XZ_()</code>함수는 <span class="math inline">\(\mu_k\)</span>와 <span class="math inline">\(\pi_k\)</span>를 <code>(K,D)</code>, <code>(K,)</code> 형태로 전달받으므로 <code>minimize()</code>함수에 바로 사용할 수 없다. 그래서 <span class="math inline">\(\mu_k\)</span>와 <span class="math inline">\(\pi_k\)</span> 한 줄로 펴서 벡터 형태로 만든 다음 전달할 래퍼함수를 하나 더 만든다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loglikelihood_XZ(theta, X, Z):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">    theta[:K*D] : mu, (K,D)   </span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">    theta[K*D:] : pi, (K,)    </span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">    X           : (N,D)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Z           : (N,K)</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------------------------------</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">    N,D,K : gloval variables</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># N, D, K = X.shape[0], X.shape[1], Z.shape[1]</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> theta[:K<span class="op">*</span>D].reshape(K,D)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> theta[<span class="op">-</span>K:]</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loglikelihood_XZ_(mu, pi, X, Z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>위 함수는 모든 <span class="math inline">\(\mu_k\)</span>와 <span class="math inline">\(\pi_k\)</span>를 담은 1차원 벡터 <code>theta</code>를 전달 받는다. 그 후 적당히 <code>theta</code>를 분리하고 <code>loglikehood_XZ_()</code>함수에 전달하고 있다.</p>
<p>앞서 정의한 두 함수가 같은 값을 계산하는지 확인해본다. 같은 값이 나오면 최종적으로 음수를 곱해서 NLL(Negative Log Likelihood)로 만든다. 사이파이에서 제공하는 <code>minimize()</code>함수는 최소화를 수행하기 때문이다.</p>
<div class="cell" data-outputid="1e47e63c-1f27-4a2e-e9e7-dfc9bb0a4e3a">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 래퍼함수와 원함수 결과가 같게 나오는지 확인</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.hstack((mu_0.flatten(),  pi_0))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(loglikelihood_XZ_(mu_0, pi_0, X, Z))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(loglikelihood_XZ(theta, X, Z))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 로그 가능도 함수의 최대화를 마이너스 로그 가능도함수의 최소화로 바꾸기 위해</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 보조 함수 정의</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> negative_loglikelihood_XZ(theta, X, Z):</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>loglikelihood_XZ(theta, X, Z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>-23.26286598620995
-23.26286598620995</code></pre>
</div>
</div>
<p>이제 각 변수에 대해서 적당히 바운드 제약조건을 설정한다. 각 파라미터에 대해 <span class="math inline">\(0 \le \pi_k, \mu_k \le 1\)</span>가 보장되어야 할것이다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 바운드 제약조건</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>bounds <span class="op">=</span> Bounds((<span class="fl">0.</span>, <span class="fl">0.</span>,   <span class="co"># mu_k의 하한</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>                 <span class="fl">0.</span>, <span class="dv">0</span>),   <span class="co"># pi_k의 하한</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                (<span class="fl">1.</span>, <span class="fl">1.</span>,   <span class="co"># mu_k의 상한 </span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                 <span class="fl">1.</span>, <span class="fl">1.</span>))  <span class="co"># pi_k의 상한</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><span class="math inline">\(\pi_k\)</span>는 멀티누이 변수 <span class="math inline">\(\mathbf{z}\)</span>의 파라미터이기 때문에 모두 더해서 1이 되어야 하므로 다음처럼 제약조건을 추가한다.</p>
<p><span class="math display">\[
\sum_{k=1}^K \pi_k = 1
\]</span></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 등호제약조건, p(z)에 대한 제약조건 다 더해서 1</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co"># sum pi = 1</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> constraint(theta):</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> theta[<span class="op">-</span>K:]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pi.<span class="bu">sum</span>() <span class="op">-</span> <span class="fl">1.</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>cons   <span class="op">=</span> ( {<span class="st">'type'</span>: <span class="st">'eq'</span>,   <span class="st">'fun'</span>: constraint   }, )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>이제 목적함수와 제약조건을 <code>minimize()</code>함수에 넘기면 최적화 과정이 수행된다.</p>
<div class="cell" data-outputid="eff30417-7dba-4e6b-dc6f-0ad95d52054c">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 파라미터를 펼쳐서 1차원 배열 하나로 만든다.</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.hstack((mu_0.flatten(), pi_0))</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.copy(theta)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Init. input:'</span>, x)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> minimize(negative_loglikelihood_XZ, x, args<span class="op">=</span>(X, Z), method<span class="op">=</span><span class="st">'slsqp'</span>, </span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>               bounds<span class="op">=</span>bounds, constraints<span class="op">=</span>cons,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>               options<span class="op">=</span>{<span class="st">'iprint'</span>: <span class="dv">2</span>, <span class="st">'disp'</span>: <span class="va">True</span>})</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"sum pi_k:"</span>,res.x[<span class="dv">2</span>:].<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Init. input: [0.4 0.3 0.5 0.5]
  NIT    FC           OBJFUN            GNORM
    1     6     2.326287E+01     5.484928E+01
    2    13     1.895467E+01     4.216554E+01
    3    20     1.694546E+01     3.614093E+01
    4    27     1.525500E+01     3.100563E+01
    5    34     1.433698E+01     2.762727E+01
    6    41     1.327568E+01     2.376365E+01
    7    47     1.170940E+01     2.275331E+01
    8    53     1.132655E+01     1.118621E+01
    9    59     1.112874E+01     7.772592E+00
   10    65     1.110341E+01     7.117206E+00
   11    71     1.110208E+01     7.069603E+00
   12    77     1.110207E+01     7.071547E+00
Optimization terminated successfully.    (Exit mode 0)
            Current function value: 11.102073936079918
            Iterations: 12
            Function evaluations: 77
            Gradient evaluations: 12
     fun: 11.102073936079918
     jac: array([-3.89838219e-03,  4.10699844e-03, -4.99865413e+00, -5.00201964e+00])
 message: 'Optimization terminated successfully.'
    nfev: 77
     nit: 12
    njev: 12
  status: 0
 success: True
       x: array([0.83331527, 0.35004671, 0.60016153, 0.39983847])
sum pi_k: 1.0</code></pre>
</div>
</div>
<p>몇 회 반복 후 다음처럼 해를 찾게 된다.</p>
<p><code>x: array([0.83331527, 0.35004671, 0.60016153, 0.39983847])</code></p>
<p>수치적으로 찾은 해는</p>
<p><span class="math display">\[
\mu_1 = 0.83331527, \quad \mu_2=0.35004671, \quad \pi_1=0.60016153, \quad \pi_2=0.39983847
\]</span></p>
<p>이며 출력 마지막 줄 <code>sum pi_k: 1.0</code>를 보면 <span class="math inline">\(\pi_k\)</span>에 대한 제약조건도 잘 지켜지고 있음을 알 수 있다. 사실 이 정도 문제는 가능도 함수가 복잡하지 않아서 직접 미분하여 해석적으로 최대 가능도 해를 구할 수 있다.</p>
</section>
<section id="해석적-방법" class="level3">
<h3 class="anchored" data-anchor-id="해석적-방법">해석적 방법</h3>
<p>가능도 함수를 직접 미분하여 최적해를 바로 찾아보자. 식(9.36)을 <span class="math inline">\(\mu_j\)</span>와 <span class="math inline">\(\pi_j\)</span>로 미분한다.</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial}{\partial \mu_j} \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})
&amp;= \frac{\partial}{\partial \mu_j} \sum_{n=1}^N \sum_{k=1}^K z_{nk} \{ \ln \pi_k + \ln \text{Bin}(x_n \mid  n_t, \mu_k) \} \\
&amp;= \sum_{n=1}^N \sum_{k=1}^K z_{nk}  \left\{ \frac{\partial}{\partial \mu_j} \ln \pi_k +  \frac{\partial}{\partial \mu_j} \ln \text{Bin}(x_n \mid  n_t, \mu_k)  \right\} \\
&amp;= \sum_{n=1}^N \sum_{k=1}^K z_{nk} \left[ \frac{\partial}{\partial \mu_j}  \left\{ \ln \begin{pmatrix} n_t \\ x_n \end{pmatrix} \mu_k^{x_n} (1-\mu_k)^{(n_t - x_n)} \right\} \right] \\
&amp;= \sum_{n=1}^N \sum_{k=1}^K z_{nk} \left[ \frac{\partial}{\partial \mu_j}  \left\{ \ln \begin{pmatrix} n_t \\ x_n \end{pmatrix} + {x_n} \ln \mu_k + {(n_t - x_n)} \ln  (1-\mu_k) \right\} \right]
\end{aligned}
\]</span></p>
<p>위 과정에서 세 번째 등호는 <span class="math inline">\(\ln \pi_k\)</span>가 <span class="math inline">\(\mu_j\)</span>의 함수가 아니므로 성립한다. 마지막 줄에서 <span class="math inline">\(\{ \}\)</span>안을 미분하면 <span class="math inline">\(k=j\)</span>인 경우를 제외하고는 모두 0이 된다. <span class="math inline">\(\{ \}\)</span>안 첫째 항은 <span class="math inline">\(\mu_j\)</span>에 대해서 상수라서 사라지고 둘째항과 셋째항을 미분하면 아래와 같다.</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial}{\partial \mu_j} \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) &amp;= \sum_{n=1}^N z_{nj} \left( \frac{x_n}{\mu_j} - \frac{n_t - x_n}{1-\mu_j} \right) \\
&amp;= \sum_{n=1}^N z_{nj} \left( \frac{x_n - n_t \mu_j}{\mu_j (1-\mu_j)} \right)
\end{aligned}
\]</span></p>
<p>마지막 식을 0으로 두고 정리한다.</p>
<p><span class="math display">\[
\sum_{n=1}^N z_{nj} \left( \frac{x_n - n_t \mu_j}{\mu_j (1-\mu_j)} \right)=0
\]</span></p>
<p>인덱스 <span class="math inline">\(n\)</span>에 관계없는 항을 합산 기호 밖으로 뽑아낸다.</p>
<p><span class="math display">\[
\frac{1}{\mu_j (1-\mu_j)} \sum_{n=1}^N z_{nj} \left(x_n - n_t \mu_j \right) = 0
\]</span></p>
<p>그러면 합산 기호에 의한 항이 0이 되어야 하므로</p>
<p><span class="math display">\[
\sum_{n=1}^N z_{nj} \left(x_n - n_t \mu_j \right) = 0
\]</span></p>
<p>합산 기호를 분배하고</p>
<p><span class="math display">\[
\sum_{n=1}^N z_{nj} x_n - \sum_{n=1}^N z_{nj} n_t \mu_j = 0
\]</span></p>
<p>이항한다.</p>
<p><span class="math display">\[
n_t \mu_j \sum_{n=1}^N z_{nj} = \sum_{n=1}^N z_{nj} x_n
\]</span></p>
<p>좌변에 <span class="math inline">\(\mu_j\)</span>만 남기고 우변으로 넘기면</p>
<p><span class="math display">\[
\mu_j = \frac{\sum_{n=1}^N z_{nj} x_n }{n_t \sum_{n=1}^N z_{nj} }
\]</span></p>
<p>위 식에서 $ <em>{n=1}^N z</em>{nj}=N_j$이므로 최종적으로</p>
<p><span class="math display">\[
\mu_j= \frac{\sum_{n=1}^N z_{nj} x_n}{n_t N_j} \tag{1}
\]</span></p>
<p>구해진 식(1)은 <span class="math inline">\(j\)</span>번째 분포를 따르는 샘플들의 평균으로 완전 데이터 세트에 대한 최대 가능도 해가 구해짐을 말해준다.</p>
<p>이제 <span class="math inline">\(\pi_j\)</span>에 대해서 미분하여 같은 과정을 반복한다. 단 이 때는 수치적 방법에서와 마찬가지로 <span class="math inline">\(\pi_k\)</span>를 모두 더해서 1이 되어야 한다는 제약조건을 고려해야한다.</p>
<p><span class="math display">\[
\sum_{k=1}^K \pi_k = 1
\]</span></p>
<p>물론 <span class="math inline">\(\mu_k\)</span>에도 $ 0 _k $라는 제약조건이 있지만 미분할 때 반영하지 않은 이유(http://www.iro.umontreal.ca/~slacoste/teaching/ift6269/A19/ 에 lecture 4 참고) 는 제약 없이 구해진 해가 제약조건을 만족시키기 때문이다. 식(1)을 보면 구해진 최종해가 <span class="math inline">\(\mu_j \in [0,1]\)</span>임을 알 수 있다.</p>
<p><span class="math inline">\(\pi_j\)</span>로 미분하는 과정은 이렇게 제약조건을 반영해야해서 조금 번거롭지만 그리 복잡하진 않기 때문에 직접 해보기로 하자. 라그랑지 승수lagrange multiplier <span class="math inline">\(\lambda\)</span>를 도입하고 라그랑지안lagrangian을 구성하자.</p>
<p><span class="math display">\[
\mathcal{L}(\boldsymbol{\theta}, \lambda)= \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) + \lambda \left( \sum_{i=1}^K \pi_i -1 \right) \tag{2}
\]</span></p>
<p>식(2)를 <span class="math inline">\(\pi_j\)</span>에 대해서 미분하는 과정은 다음과 같다.</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial}{\partial \pi_j} &amp; \left\{ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) + \lambda \left( \sum_{i=1}^K \pi_i -1 \right) \right\} \\
&amp;= \frac{\partial}{\partial \pi_j} \left[  \sum_{n=1}^N \sum_{k=1}^K z_{nk} \{ \ln \pi_k + \ln \text{Bin}(x_n \mid  n_t, \mu_k) \}  + \lambda \left( \sum_{i=1}^K \pi_i -1 \right) \right] \\
&amp;= \sum_{n=1}^N \sum_{k=1}^K    z_{nk} \left\{\frac{\partial}{\partial \pi_j} \ln \pi_k + \frac{\partial}{\partial \pi_j} \ln \text{Bin}(x_n \mid  n_t, \mu_k) \right\}  + \lambda \left(  \sum_{k=1}^K  \frac{\partial}{\partial \pi_j}(\pi_i -1) \right) \\
&amp;= \sum_{n}^N \left(  \frac{z_{nj}}{\pi_j}\right) + \lambda
\end{aligned} \tag{3}
\]</span></p>
<p>식(2)를 <span class="math inline">\(\lambda\)</span>에 대해 미분하면 다음과 같다.</p>
<p><span class="math display">\[
\frac{\partial}{\partial \lambda} \left\{ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) + \lambda \left( \sum_{i=1}^K \pi_i -1 \right) \right\} =\sum_{i=1}^K \pi_i -1 \tag{4}
\]</span></p>
<p>이제 식(3),(4)를 모두 0으로 두고 연립방정식을 풀어서 해를 구한다.</p>
<p><span class="math display">\[
\sum_{n}^N \left(  \frac{z_{nj}}{\pi_j}\right) + \lambda = 0 \tag{5}
\]</span></p>
<p><span class="math display">\[
\sum_{j=1}^K \pi_j -1 = 0 \tag{6}
\]</span></p>
<p>식(5)으로 부터</p>
<p><span class="math display">\[
\pi_j = -\frac{N_j}{\lambda} \tag{7}
\]</span></p>
<p>을 얻고 식(7)을 식(6)에 대입하면 <span class="math inline">\(\lambda = -N\)</span>을 구할 수 있다. 따라서 최종적으로</p>
<p><span class="math display">\[
\pi_j = \frac{N_j}{N} \tag{8}
\]</span></p>
<p>완전 데이터 세트에 대한 최대 가능도 추정은 식(1)과 식(8)로 주어진다. 확률분포에 대한 인덱스를 일관적으로 사용하기 위해 인덱스를 <span class="math inline">\(k\)</span>로 바꾸고 다시 적으면 다음과 같다.</p>
<p><span class="math display">\[
\mu_k= \frac{\sum_{n=1}^N z_{nk} x_n}{n_t N_k} \tag{9}
\]</span></p>
<p><span class="math display">\[
\pi_k = \frac{N_k}{N} \tag{10}
\]</span></p>
<p>식(9), (10)은 최대 가능도 추정을 통해 구해진 분포의 파라미터 <span class="math inline">\(\mu_k\)</span>는 <span class="math inline">\(k\)</span>번 째 분포를 따르는 샘플들의 평균이며 혼합계수 <span class="math inline">\(\pi_k\)</span>는 간단히 분포를 따르는 샘플들의 비가 됨을 알려준다.</p>
<p>이 결과를 주어진 데이터에 적용해보면 10, 7, 8은 <span class="math inline">\(\text{Bin}(x \mid n_t = 10, \mu_1)\)</span>로 부터 나온 데이터이므로 식(9)에 의해</p>
<p><span class="math display">\[
\mu_1 = \frac{10+7+8}{10 \times 3}=\frac{25}{30}= 0.833333
\]</span></p>
<p>4, 3은 <span class="math inline">\(\text{Bin}(x \mid n_t=10, \mu_2)\)</span>로 부터 나온 데이터이므로</p>
<p><span class="math display">\[
\mu_2 = \frac{4+3}{10 \times 2}=\frac{7}{20}= 0.35
\]</span></p>
<p>이 된다. 혼합계수에 대해서는 식(10)에 의해 해 <span class="math display">\[
\pi_1 = \frac{3}{5}=0.6, \qquad \pi_2 = \frac{2}{5}=0.4
\]</span></p>
<p>로 완전 데이터 세트의 최대 가능도 해를 구할 수 있다. 수치적으로 구한 해와 거의 같은 해가 구해지는 것을 확인할 수 있다.</p>
<p>지금까지 과정을 통해 완전 데이터 세트에 대해서는 가능도 함수를 최대화 시키는 방식으로 비교적 간단하게 파라미터를 추정할 수 있다는 사실을 알았다. 하지만 문제는 우리에게 행렬 <span class="math inline">\(\mathbf{Z}\)</span>에 대한 정보가 전혀 없다는 것이다. 다시말해 우리에게 주어진 데이터는 불완전 데이터 세트incomplete data set이다.</p>
</section>
</section>
<section id="모르는-데이터를-어떻게-할-것인가" class="level2">
<h2 class="anchored" data-anchor-id="모르는-데이터를-어떻게-할-것인가">모르는 데이터를 어떻게 할 것인가?</h2>
<section id="평균이란" class="level3">
<h3 class="anchored" data-anchor-id="평균이란">평균이란?</h3>
<p>이쯤에서 잠시 머리를 식힐겸 평균에 대해서 이야기해보자. 우리는 주어진 데이터를 정리하는 개념으로 평균을 인식하는 경우가 많다. 예를 들어 10명인 반의 시험 점수 10개를 다 들여다보기 보다 평균점만 보고 그 반의 성적을 대강 짐작하는 식으로 평균을 사용하게 된다. 하지만 평균은 우리가 알고 싶은 숫자를 잘 모를 때 사용할 수도 있다. 비슷한 수준의 학생이 입학한다고 했을 때 열한 번째 학생의 성적을 모르지만 앞서 구해놓은 평균으로 예측해볼 수 있다는 것이다.</p>
<p>예를 들어보자. 당신은 프로야구팀 감독이며 팀 성적이 좋아서 한국시리즈까지 진출했다. 내일 1차전이 열리는데 우리팀의 승률을 알고 싶다고 하자. 우리팀의 승률은 상대팀의 선발투수에 따라서 달라지는 것이 당연할 것이다. 수석코치에게 물어보니 시즌 전적을 바탕으로 볼 때 1선발이 등판하면 우리팀 승률은 0.45, 2선발이 등판하면 0.6이라고 한다. 모종의 이유로 1차전에 1선발이 등판할지 2선발이 등판할지 예측할 수 없다면 수석코치는 감독에게 1차전 승률을 어떻게 보고해야할까? 대부분 사람들이 당연하다는 듯이 다음처럼 평균을 구할 것이다.</p>
<p><span class="math display">\[
\frac{0.45+0.6}{2}=0.525 \tag{11}
\]</span></p>
<p>위 식은 1선발과 2선발이 등판할 확률을 모르기 때문에 같다고 임의로 결정한 결과이다. 그런데 만약 1선발이 등판할 확률이 80%라면 예측이 좀 달라져야하지 않을까?</p>
<p><span class="math display">\[
0.8 \times 0.45 + 0.2 \times 0.6 = 0.48 \tag{12}
\]</span></p>
<p>즉 시합 열 번중에 여덟 번은 1선발이 등판하고 두 번은 2선발이 등판한다고 했을 때 평균을 구한 것이다. 만약 상대팀이 선발등판 예고를 2선발로 했다면 더 볼 것도 없이 승률은 0.6이 된다.</p>
<p><span class="math display">\[
0 \times 0.45 + 1 \times 0.6 = 0.6 \tag{13}
\]</span></p>
<p>지금 우리가 무엇을 하고 있는지 생각해보자.</p>
<p>상대팀의 선발투수 등판 상태 상태에는 1선발이 나오거나 2선발이 나오거나 두가지 상태가 있다. 다만 이 두 가지 중 어떤 상태로 결정될지는 알 수 없다. 대신 각 상태에 대한 확률을 ‘모두’ 알고 있다면 모든 상태에 대해서 평균을 계산하여 내일 승률을 예측할 수 있는 것이다. 식(11)에서는 각 상태에 50%씩 확률을 할당한 경우, 식(12)는 1선발이 등판하는 상태1에 80%, 2선발이 등판하는 상태2에 20%를 할당한 경우, 식(13)은 상태1에 0%, 상태2에 100%를 할당한 경우에 승률을 계산한 것이다.</p>
<p>이렇게 알 수 없는 정보가 있는데 그 정보가 가질 수 있는 모든 상태에 대해서 확률을 할당할 수 있다면 평균을 구해서 모르는 부분을 채울 수 있는 것이다.</p>
</section>
<section id="전체적인-전략" class="level3">
<h3 class="anchored" data-anchor-id="전체적인-전략">전체적인 전략</h3>
<p>우리는 <span class="math inline">\(\mathbf{Z}\)</span>가 어떤 모양인지 모른다. 여기서 앞선 논의를 적용해보자.</p>
<ol type="1">
<li><span class="math inline">\(\mathbf{Z}\)</span>를 모르기 때문에 <span class="math inline">\(\mathbf{Z}\)</span>가 가능한 모든 상태를 생각해보자.</li>
<li>그리고 그 상태들에 확률을 부여할 수 있다고 가정해보자.</li>
<li>그러면 모든 상태에 대해서 가능도 함숫값을 구하고 그렇게 구해진 함숫값들을 해당 <span class="math inline">\(\mathbf{Z}\)</span>에 부여된 확률을 이용해서 평균낼 수 있지 않을까?</li>
<li>그렇게만 할 수 있다면 그 가능도 함숫값의 평균을 최대화하는 파라미터를 찾을 수 있을 것이다.</li>
</ol>
<p>마지막 4번 문장에서 평균을 기댓값이란 용어로 바꿔보자.</p>
<blockquote class="blockquote">
<p>“그렇게만 할 수 있다면 그 가능도 함숫값의 <strong>기댓값을 최대화</strong>하는 파라미터를 찾을 수 있을 것이다.”</p>
</blockquote>
<p>우리가 알고 싶어하는 기댓값 최대화라는 이슈가 등장한 것이다!</p>
<p>다시 정리하자. 우리에게 완전 데이터 세트가 주어져 있다면 데이터의 파라미터에 대한 가능도 함숫값을 계산할 수 있고 이를 통해 최대화를 수행할 수 있다. 하지만 불완전 데이터 세트가 주어졌기 때문에 가능도 함숫값을 계산할 수 없다. 대신 모르는 데이터에 대해서 가능한 모든 상태를 상정하고 가능도 함숫값을 구해 그것들의 평균을 계산한다. 이 평균을 최대화 해보자는 것이다.</p>
<p>현재 설정된 문제에서 가능한 <span class="math inline">\(\mathbf{Z}\)</span>는 모두 <span class="math inline">\(2^5=32\)</span>가지가 있다. 이제 우리에게 주어진 첫 번째 과제는 존재 가능한 모든 <span class="math inline">\(\mathbf{Z}\)</span>에 대해서 확률을 부여하는 것이다.</p>
</section>
</section>
</section>
<section id="em-알고리즘---2편" class="level1">
<h1>EM 알고리즘 - 2편</h1>
<p>사실 지난 편을 통해 EM 알고리즘의 가장 핵심적인 사항을 모두 이야기하였다. 모든 데이터를 알고 있을 때 계산할 수 있는 가능도 함숫값의 기대값을 최대화 하는 것이 핵심이다. 여기서 문제는 가능도 함숫값을 구할 수 없는데 그 평균은 구할 수 있다고 하는 부분이다. 언뜻 생각해서는 이게 가능한가 싶은 생각이 든다. 여기에 대해서 구체적으로 이야기 하기 전에 불완전 데이터 세트에 대한 가능도 함수를 직접 구성해서 문제를 해결해보도록 하자. 이 과정을 통해 평균을 최대화 시키는 방법에 대한 부가적인 이유도 짐작해볼 수 있게 된다.</p>
<section id="불완전-데이터-세트에-대한-최대-가능도-추정" class="level2">
<h2 class="anchored" data-anchor-id="불완전-데이터-세트에-대한-최대-가능도-추정">불완전 데이터 세트에 대한 최대 가능도 추정</h2>
<section id="가능도-함수-1" class="level3">
<h3 class="anchored" data-anchor-id="가능도-함수-1">가능도 함수</h3>
<p>현재 주어진 데이터 세트가 불완전 데이터 세트라면 <span class="math inline">\(\ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})\)</span>를 구할 수 없기 때문에 <span class="math inline">\(\mathbf{z}\)</span>를 주변화 시켜 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 직접구하는 전략을 써볼 수 있다. 주어진 <span class="math inline">\(\mathbf{X}\)</span>를 가장 잘 발생시킬것 같은 <span class="math inline">\(\boldsymbol{\theta}\)</span>를 찾는 것이 최대 가능도 추정이므로 궁극적으로는 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 최대화 시키고 싶은 것이다.</p>
<p>앞서 직관적인 방법으로 식(9.7)로 <span class="math inline">\(p(x)\)</span>를 정의했었는데 여기서 정식으로 유도해보도록 하자. 우선 식(9.10)은 멀티누이 변수의 확률질량함수이므로 그 자체로 타당하다.</p>
<p><span class="math display">\[
p(\mathbf{z}) = \prod_{k=1}^{K} \pi_k^{z_k} \tag{9.10}
\]</span></p>
<p>다음으로 어떤 확률분포인지 알려주는 <span class="math inline">\(\mathbf{z}\)</span>가 주어졌다면 <span class="math inline">\(x\)</span>에 대한 확률분포는 주어진 이항분포 <span class="math inline">\(K\)</span>개중 하나가 되므로 식(9.11)도 어렵지 않게 이해할 수 있다.</p>
<p><span class="math display">\[
p(x \mid \mathbf{z}) = \prod_{k=1}^K \text{Bin}(x \mid n_t, \mu_k)^{z_k} \tag{9.11}
\]</span></p>
<p>확률의 곱법칙에 의해 <span class="math inline">\(p(x,\mathbf{z})=p(\mathbf{z})p(x \mid \mathbf{z})\)</span>이므로 다음이 성립하고</p>
<p><span class="math display">\[
p(x,\mathbf{z}) = \prod_{k=1}^K \pi_k^{z_k} \text{Bin}(x \mid n_t, \mu_k)^{z_k}
\]</span></p>
<p>이를 확률의 합법칙에 의해 <span class="math inline">\(\mathbf{z}\)</span>에 대해서 주변화 하면 <span class="math inline">\(p(x)\)</span>를 얻을 수 있다.</p>
<p><span class="math display">\[
p(x) = \sum_{\mathbf{z}}  \prod_{k=1}^K \pi_k^{z_k} \text{Bin}(x \mid n_t, \mu_k)^{z_k}
\]</span></p>
<p>위 식에서 <span class="math inline">\(\prod\)</span>에 의해 곱해지는 항 <span class="math inline">\(K\)</span>개는 <span class="math inline">\(z_k\)</span>가 오직 하나만 1이고 나머지는 다 0인 상태이다. 따라서 한 개 항만 살아남는다. 그런 항 <span class="math inline">\(K\)</span>개를 모든 <span class="math inline">\(\mathbf{z}\)</span>에 대해서 다 더하고 있으므로 결과적으로는 <span class="math inline">\(K\)</span>개 항만 더해지는 것으로 다음처럼 정리된다.</p>
<p><span class="math display">\[
p(x) = \sum_{\mathbf{z}}  \prod_{k=1}^K \pi_k^{z_k} \text{Bin}(x \mid n_t, \mu_k)^{z_k} = \sum_{i=1}^K \pi_k \text{Bin}(x \mid n_t, \mu_k) \tag{9.12}
\]</span></p>
<p>직관적으로 정의 했던 식(9.7)을 다시 얻을 수 있다. 굳이 힘들게 <span class="math inline">\(p(x)\)</span>를 유도한 이유는 유도 과정에서 <span class="math inline">\(\mathbf{z}\)</span>를 주변화해야만 하고 그로 인해 최종 식에 <span class="math inline">\(\sum_{k}\)</span>가 등장한다는 것을 보이기 위함이다. 식(9.12)에서 <span class="math inline">\(\boldsymbol{\theta}=(\pi_1, \pi_2, ..., \pi_k, \mu_1, \mu_2, ..., \mu_k)^{\text{T}}\)</span>로 두면</p>
<p><span class="math display">\[
p(x \mid \boldsymbol{\theta}) = \sum_{i=1}^K \pi_k \text{Bin}(x \mid n_t, \mu_k)
\]</span></p>
<p>로 쓸 수 있고, 모든 데이터를 고려하기 위해 데이터에 인덱스 <span class="math inline">\(n\)</span>을 도입하면</p>
<p><span class="math display">\[
p(x_n \mid \boldsymbol{\theta}) = \sum_{i=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)
\]</span></p>
<p>이 된다. <span class="math inline">\(\boldsymbol{\theta}\)</span>에 대한 가능도를 구하기 위해 모든 데이터에 대해 곱해준다.</p>
<p><span class="math display">\[
p(\mathbf{X} \mid \boldsymbol{\theta}) = \prod_{n=1}^N \sum_{i=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)
\]</span></p>
<p>이제 위 식에 로그를 적용하면</p>
<p><span class="math display">\[
\ln p(\mathbf{X} \mid \boldsymbol{\theta} )
= \sum_{n=1}^N \ln \left\{  \sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k)  \right\} \tag{9.14}
\]</span></p>
<p>불완전 데이터 세트에 대한 로그 가능도 함수가 구해진다. 이제 <span class="math inline">\(\mathbf{Z}\)</span>를 몰라도 데이터에 대한 가능도 함숫값을 구할 수 있다.</p>
</section>
<section id="수치적-방법-1" class="level3">
<h3 class="anchored" data-anchor-id="수치적-방법-1">수치적 방법</h3>
<p>식(9.14)를 최대화 시키기 위해 수치적 수법을 적용해보자. 과정은 완전 데이터 세트에 대한 수치 최적화 과정과 완전히 동일하다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loglikelihood_X_(mu, pi, X):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">    EQ(9.14)</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">    mu     : (K,D)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">    pi     : (K,)</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co">    X      : (N,D)</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">    --------------------------------------------</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">    N,D,K  : gloval variables</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># N, D = X.shape[0], X.shape[1]</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    sigma_n <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        sigma_k <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(K):</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>            likelihood_x <span class="op">=</span> binom.pmf(X[n,<span class="dv">0</span>], n_t, mu[k,<span class="dv">0</span>])</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>            sigma_k <span class="op">+=</span> pi[k]<span class="op">*</span>likelihood_x</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>        sigma_n <span class="op">+=</span> np.log(sigma_k<span class="op">+</span><span class="fl">1.0e-8</span>)</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sigma_n</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loglikelihood_X(theta, X):</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="co">    theta[:K*D] : mu,     (K,D)   </span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a><span class="co">    theta[K*D:] : pi,     (K,)    </span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="co">    X           : (N,D)</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># N, D = X.shape[0], X.shape[1]</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> theta[:K<span class="op">*</span>D].reshape(K,D)</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> theta[<span class="op">-</span>K:]</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loglikelihood_X_(mu, pi, X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-outputid="55674dd0-8572-4777-eb49-ba33430fd4e2">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 래퍼함수와 원함수 결과가 같게 나오는지 확인</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mu_0, pi_0)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.hstack((mu_0.flatten(),  pi_0))</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(loglikelihood_X_(mu_0, pi_0, X)))</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(loglikelihood_X(theta, X)))</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 로그 가능도 함수의 최대화를 마이너스 로그 가능도함수의 최소화로 바꾸기 위해</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 보조 함수 정의</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> negative_loglikelihood_X(theta, X):</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>loglikelihood_X(theta, X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0.4]
 [0.3]] [0.5 0.5]
-21.484619
-21.484619</code></pre>
</div>
</div>
<div class="cell" data-outputid="ffbf955c-445e-4753-bf14-9ac1e330ef26">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 파라미터를 펼쳐서 1차원 배열 하나로 만든다.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.hstack((mu_0.flatten(), pi_0))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.copy(theta)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Init. input:'</span>, x)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> minimize(negative_loglikelihood_X, x, args<span class="op">=</span>(X,), method<span class="op">=</span><span class="st">'SLSQP'</span>, </span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>               bounds<span class="op">=</span>bounds, constraints<span class="op">=</span>cons,</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>               options<span class="op">=</span>{<span class="st">'iprint'</span>: <span class="dv">2</span>, <span class="st">'disp'</span>: <span class="va">True</span>})</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"sum pi_k:"</span>,res.x[<span class="dv">2</span>:].<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Init. input: [0.4 0.3 0.5 0.5]
  NIT    FC           OBJFUN            GNORM
    1     6     2.148462E+01     4.848786E+01
    2    13     1.577919E+01     2.542786E+01
    3    20     1.505575E+01     2.600846E+01
    4    27     1.393468E+01     2.321400E+01
    5    34     1.327015E+01     2.112075E+01
    6    41     1.246911E+01     1.746856E+01
    7    48     1.210598E+01     1.640239E+01
    8    55     1.129506E+01     1.103584E+01
    9    62     1.100341E+01     7.409348E+00
   10    68     1.097328E+01     7.157866E+00
   11    74     1.096708E+01     7.083495E+00
   12    80     1.096662E+01     7.070962E+00
   13    86     1.096662E+01     7.071087E+00
Optimization terminated successfully.    (Exit mode 0)
            Current function value: 10.96661829509231
            Iterations: 13
            Function evaluations: 86
            Gradient evaluations: 13
     fun: 10.96661829509231
     jac: array([-2.94947624e-03,  1.06954575e-03, -4.99991703e+00, -5.00010955e+00])
 message: 'Optimization terminated successfully.'
    nfev: 86
     nit: 13
    njev: 13
  status: 0
 success: True
       x: array([0.83809726, 0.37573062, 0.57156103, 0.42843897])
sum pi_k: 1.0</code></pre>
</div>
</div>
<p>구해진 결과는</p>
<p><code>x: array([0.83809726, 0.37573062, 0.57156103, 0.42843897])</code></p>
<p>이다. 원래 파라미터 변수명으로 적어보면</p>
<p><span class="math display">\[
\mu_1 = 0.83809726, \quad \mu_2=0.37573062, \quad \pi_1=0.57156103, \quad \pi_2=0.42843897
\]</span></p>
<p>이다. 완전 데이터 세트에서 결과와 비슷한지만 비교해보자. 첫 행은 완전 데이터 세트에 대한 결과이고 다음 행은 불완전 데이터 세트에 대한 결과이다.</p>
<ul>
<li><span class="math inline">\(\mu_1 = 0.83331527, \quad \mu_2=0.35004671, \quad \pi_1=0.60016153, \quad \pi_2=0.39983847\)</span></li>
<li>$ _1 = 0.83809726, _2=0.37573062, _1=0.57156103, _2=0.42843897$</li>
</ul>
<p>어느정도 유사하게 추정된 것을 확인할 수 있다. 데이터가 더 많았다면 두 결과는 더 비슷해질것이다.</p>
</section>
<section id="해석적-방법-1" class="level3">
<h3 class="anchored" data-anchor-id="해석적-방법-1">해석적 방법</h3>
<p>이제 완전 데이터 세트에서 했던 것처럼 직접 미분하여 해를 찾아보자. 이 과정에서 <span class="math inline">\(\mathbf{z}\)</span>를 주변화한 것이 어떤 결과를 낳게되는지 확인할 수 있다. 다만 미분 과정에 지저분해서 계산이 꽤 성가시다. 그래서 미분 과정에 별 관심이 없다면 식(9.22)까지 바로 건너 뛰기로 하자.</p>
<p>먼저 <span class="math inline">\(\mu_j\)</span>로 미분한다.</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial}{\partial \mu_j} \ln p(\mathbf{X} \mid \boldsymbol{\theta})
&amp;= \frac{\partial}{\partial \mu_j}\left[\sum_{n=1}^N \ln \left\{  \sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k)  \right\} \right] \\
&amp;= \sum_{n=1}^N \frac{1}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \frac{\partial}{\partial \mu_j} \sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) \\
&amp;= \sum_{n=1}^N \frac{1}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \frac{\partial}{\partial \mu_j} \sum_{k=1}^K  \pi_k \begin{pmatrix} n_t \\ x_n \end{pmatrix} \mu_k^{x_n} (1-\mu_k)^{(n_t - x_n)}
\end{aligned}\tag{14}
\]</span></p>
<p>미분하는 부분만 따로 때서 써보면</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial}{\partial \mu_j} &amp; \sum_{k=1}^K  \pi_k \begin{pmatrix} n_t \\ x_n \end{pmatrix}    \mu_k^{x_n} (1-\mu_k)^{(n_t - x_n)} \\
&amp;=   \pi_j \begin{pmatrix} n_t \\ x_n \end{pmatrix} \left\{ x_n \mu_j^{(x_n -1)} (1-\mu_j)^{(n_t-x_n)} - \mu_j^{x_n}(n_t - x_n)(1-\mu_j)^{(n_t - x_n-1)} \right\} \\[10pt]
&amp;= \pi_j \begin{pmatrix} n_t \\ x_n \end{pmatrix} \left\{ x_n \mu_j^{x_n} \mu_j^{-1}(1-\mu_j)^{(n_t-x_n)}- \mu_j^{x_n}(n_t - x_n) (1-\mu_j)^{(n_t - x_n)}(1-\mu_j)^{-1} \right\} \\[10pt]
&amp;= \pi_j \begin{pmatrix} n_t \\ x_n \end{pmatrix} \left\{\frac{x_n \mu_j^{x_n}(1-\mu_j)^{(n_t-x_n)}}{\mu_j} - \frac{(n_t - x_n) \mu_j^{x_n} (1-\mu_j)^{(n_t - x_n)}}{(1-\mu_j)} \right\}
\end{aligned} \tag{15}
\]</span></p>
<p>편미분 과정에서 <span class="math inline">\(j=k\)</span>인 경우만 남게 되고 합산 기호는 사라진다.</p>
<p>미분 결과 식(15)를 다시 식(14)에 대입하고 정리하자.</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial}{\partial \mu_j} \ln p(\mathbf{X} \mid \boldsymbol{\theta})
&amp;=\sum_{n=1}^N \frac{1}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \pi_j \begin{pmatrix} n_t \\ x_n \end{pmatrix} \left\{\frac{x_n \mu_j^{x_n}(1-\mu_j)^{(n_t-x_n)}}{\mu_j} - \frac{(n_t - x_n) \mu_j^{x_n} (1-\mu_j)^{(n_t - x_n)}}{(1-\mu_j)} \right\} \\[5pt]
&amp;=\sum_{n=1}^N \frac{1}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \pi_j  \left\{\frac{x_n \begin{pmatrix} n_t \\ x_n \end{pmatrix} \mu_j^{x_n}(1-\mu_j)^{(n_t-x_n)}}{\mu_j} - \frac{(n_t - x_n) \begin{pmatrix} n_t \\ x_n \end{pmatrix} \mu_j^{x_n} (1-\mu_j)^{(n_t - x_n)}}{(1-\mu_j)} \right\} \\[5pt]
&amp;= \sum_{n=1}^N \frac{1}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \pi_j  \left\{\frac{x_n \text{Bin}(x_n \mid n_t, \mu_j)}{\mu_j} - \frac{(n_t - x_n) \text{Bin}(x_n \mid n_t, \mu_j)}{(1-\mu_j)} \right\} \\[5pt]
&amp;= \sum_{n=1}^N \frac{1}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \pi_j  \left\{ \frac{x_n \text{Bin}(x_n \mid n_t, \mu_j)-\mu_j n_t \text{Bin}(x_n \mid n_t, \mu_j)}{\mu_j (1-\mu_j)} \right\}\\[5pt]
&amp;= \sum_{n=1}^N \frac{1}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) }   \left\{ \frac{\pi_j x_n \text{Bin}(x_n \mid n_t, \mu_j)- \pi_j \mu_j n_t \text{Bin}(x_n \mid n_t, \mu_j)}{\mu_j (1-\mu_j)} \right\} \\[5pt]
&amp;=  \sum_{n=1}^N \frac{1}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) }   \left\{ \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j) ( x_n -  \mu_j n_t) }{\mu_j (1-\mu_j)} \right\} \\[5pt]
&amp;= \sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \cdot   \frac{  x_n -  \mu_j n_t }{\mu_j (1-\mu_j)}
\end{aligned}
\]</span></p>
<p>마지막 식을 0으로 두고 정리한다.</p>
<p><span class="math display">\[
\sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \cdot   \frac{  x_n -  \mu_j n_t }{\mu_j (1-\mu_j)} =0
\]</span></p>
<p>인덱스 <span class="math inline">\(n\)</span>에 관계없는 항을 합산 기호 밖으로 빼고</p>
<p><span class="math display">\[
\frac{  1 }{\mu_j (1-\mu_j)} \sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \cdot   (x_n -  \mu_j n_t) =0
\]</span></p>
<p>양변에 <span class="math inline">\(\mu_j (1-\mu_j)\)</span>를 곱하면</p>
<p><span class="math display">\[
\sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \cdot   (x_n -  \mu_j n_t) =0
\]</span></p>
<p>합산 기호를 분배하면</p>
<p><span class="math display">\[
\sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \cdot   x_n - \sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \cdot \mu_j n_t =0
\]</span></p>
<p>이므로</p>
<p><span class="math display">\[
\sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \cdot \mu_j n_t =\sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \cdot   x_n
\]</span></p>
<p>가 되고 적당히 이항하면</p>
<p><span class="math display">\[
\mu_j =\frac{1}{n_t  \sum_{n=1}^N \dfrac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) }}\sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \cdot   x_n
\]</span></p>
<p>위 식에서 앞 쪽 분수 분모의 합산항을</p>
<p><span class="math display">\[
N_j=\sum_{n=1}^N \frac{\pi_j\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k) } \tag{9.18}
\]</span> 을 로 두면 최종적으로 다음과 같다.</p>
<p><span class="math display">\[
\mu_j = \frac{1}{n_t N_j} \sum_{n=1}^N \left( \frac{ \pi_j \text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_j \text{Bin}(x_n \mid n_t, \mu_j) } \right) x_n \tag{9.17}
\]</span></p>
<p>이제 <span class="math inline">\(\pi_j\)</span>로 미분할 차례이다. 여기서는 완전 데이터 세트에서처럼 제약조건을 고려하여 라그랑지안을 구성하고 <span class="math inline">\(\pi_j\)</span>와 라그랑지 승수 <span class="math inline">\(\lambda\)</span>로 미분한다.</p>
<p><span class="math display">\[
\mathcal{L}(\boldsymbol{\theta}, \lambda)= \ln p(\mathbf{X} \mid \boldsymbol{\theta}) + \lambda \left( \sum_{i=1}^K \pi_i -1 \right) \tag{16}
\]</span></p>
<p>식(16)을 <span class="math inline">\(\pi_j\)</span>에 대해서 미분하는 과정은 다음과 같다.</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial}{\partial \pi_j} &amp; \left\{ \ln p(\mathbf{X} \mid \boldsymbol{\theta}) + \lambda \left( \sum_{i=1}^K \pi_i -1 \right) \right\} \\
&amp;= \frac{\partial}{\partial \pi_j} \left[  \sum_{n=1}^N \ln \left\{  \sum_{k=1}^K  \pi_k \text{Bin}(x_n \mid n_t, \mu_k)  \right\} + \lambda \left( \sum_{i=1}^K \pi_i -1 \right) \right] \\
&amp;= \sum_{n=1}^N \left(  \frac{\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)} \right) + \lambda
\end{aligned} \tag{17}
\]</span></p>
<p>식(16)를 <span class="math inline">\(\lambda\)</span>에 대해 미분하면 다음과 같다.</p>
<p><span class="math display">\[
\frac{\partial}{\partial \lambda} \left\{ \ln p(\mathbf{X} \mid \boldsymbol{\theta}) + \lambda \left( \sum_{i=1}^K \pi_i -1 \right) \right\} =\sum_{i=1}^K \pi_i -1 \tag{18}
\]</span></p>
<p>이제 식(17),(18)을 모두 0으로 두고 연립방정식을 풀어서 해를 구한다.</p>
<p><span class="math display">\[
\sum_{n=1}^N \left(  \frac{\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)} \right) + \lambda = 0 \tag{19}
\]</span></p>
<p><span class="math display">\[
\sum_{j=1}^K \pi_j -1 = 0 \tag{20}
\]</span></p>
<p>식(19) 양변에 <span class="math inline">\(\pi_j\)</span>를 곱한다.</p>
<p><span class="math display">\[
\pi_j \left[ \sum_{n=1}^N \left(  \frac{\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)} \right) + \lambda \right] = 0
\]</span></p>
<p>대괄호를 풀고 이항하면</p>
<p><span class="math display">\[
\pi_j  \sum_{n=1}^N \left(  \frac{\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)} \right)  = - \pi_j  \lambda
\]</span></p>
<p>양변을 인덱스 <span class="math inline">\(j\)</span>에 대해 합산해도 등호는 성립한다.</p>
<p><span class="math display">\[
\sum_{j=1}^K  \pi_j  \sum_{n=1}^N \left(  \frac{\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)} \right)  = - \sum_{j=1}^K \pi_j  \lambda \tag{21}
\]</span></p>
<p>식(21) 우변에 식(20)을 적용하면</p>
<p><span class="math display">\[
\underbrace{\sum_{j=1}^K   \sum_{n=1}^N \left(  \frac{\pi_j  \text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)} \right)  }_N= -  \lambda \tag{22}
\]</span></p>
<p>식(22)에서 좌변은 <span class="math inline">\(N\)</span>이 된다. 직관적으로 잘 이해가 되지 않으면 잠시 후 다시 알아보도록 하자. 어쨌든 최종적으로</p>
<p><span class="math display">\[
\lambda = -N \tag{23}
\]</span></p>
<p>임을 알 수 있다. 이제 식(23)을 식(19)에 다시 대입하고 정리한다.</p>
<p><span class="math display">\[
\sum_{n=1}^N \left(  \frac{\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)} \right) - N  = 0
\]</span></p>
<p><span class="math inline">\(N\)</span>을 이항하고 양변에 <span class="math inline">\(\pi_j\)</span>를 곱하면</p>
<p><span class="math display">\[
\pi_j \left\{ \sum_{n=1}^N \left(  \frac{\text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)} \right) \right\}   = \pi_j N
\]</span></p>
<p><span class="math inline">\(N\)</span>을 다시 이항하면</p>
<p><span class="math display">\[
\pi_j = \frac{ \sum_{n=1}^N \left(  \dfrac{ \pi_j \text{Bin}(x_n \mid n_t, \mu_j)}{\sum_{k=1}^K \pi_k \text{Bin}(x_n \mid n_t, \mu_k)} \right) }{N}
\]</span></p>
<p>분자를 식(9.18)로 바꿔쓰면</p>
<p><span class="math display">\[
\pi_j = \frac{N_j}{N} \tag{9.22}
\]</span></p>
<p>를 얻을 수 있다.</p>
<p>지루한 미분 과정이 마무리되었고 식(9.17), (9.18), (9.22)의 인덱스 <span class="math inline">\(j\)</span>를 <span class="math inline">\(k\)</span>로 바꾸고 같이 정리해보면 다음과 같은 결과를 얻게 된다.</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \mu_k = \frac{1}{n_t N_k} \sum_{n=1}^N \left( \frac{ \pi_k \text{Bin}(x_n \mid n_t, \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x_n \mid n_t, \mu_j) } \right) x_n  \\[10pt]
&amp; \pi_k = \frac{N_k}{N} \\[10pt]
&amp; \text{where}\,\,\, N_k = \sum_{n=1}^N \left( \frac{ \pi_k \text{Bin}(x_n \mid n_t, \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x_n \mid n_t, \mu_j) } \right)
\end{aligned}
\]</span></p>
<p>그런데 <span class="math inline">\(\mu_k\)</span>를 계산하는 결과를 보면 <span class="math inline">\(\mu_k\)</span>가 계산 과정에서 다시 나타나고 있다. <span class="math inline">\(\mu_k\)</span>를 구하는데 <span class="math inline">\(\mu_k\)</span>가 사용되고 있어서 닫힌형식의 해가 아님을 알 수 있다.</p>
<section id="반복법" class="level4">
<h4 class="anchored" data-anchor-id="반복법">반복법</h4>
<p>기껏 힘들게 미분을 해서 해석적으로 해를 찾았지만 해의 형태가 닫힌형식이 아니라는 결과를 확인했다. 왜 이런 결과가 나오게 되었을까? 그 이유는 모르는 데이터 <span class="math inline">\(\mathbf{z}\)</span>를 주변화해서 없애는 과정 때문에 필연적으로 로그 안에 합산 기호가 나타나기 때문이다. 로그가 지수족 분포함수에 직접 작용하게 되면 지수함수를 상쇄시켜 계산이 간단해지는 장점이 있는데 여기서는 합산 기호 때문에 그런 순기능이 발생하지 않았던 것이다. 그래서 미분 과정도 매우 복잡하며 얻게된 해도 쓸모없어 보이는 형태를 띄고 있는 것이다. 결국 이런 식으로 해를 찾을 수 없다는 결론에 이르게 되는데 여기서 좀 과감한 방법을 시도해보자.</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \color{#318CE7}{\mu_k} = \frac{1}{n_t N_k} \sum_{n=1}^N \left( \frac{ \color{#E52B50}{\pi_k} \text{Bin}(x_n \mid n_t, \color{#E52B50}{\mu_k})}{\sum_{j=1}^K \color{#E52B50}{\pi_j} \text{Bin}(x_n \mid n_t, \color{#E52B50}{\mu_j}) } \right) x_n \\[10pt]
&amp; \color{#318CE7}{\pi_k} = \frac{N_k}{N} \\[10pt]
&amp; \text{where}\,\,\, N_k = \sum_{n=1}^N \left( \frac{ \color{#E52B50}{\pi_k} \text{Bin}(x_n \mid n_t, \color{#E52B50}{\mu_k})}{\sum_{j=1}^K \color{#E52B50}{\pi_j} \text{Bin}(x_n \mid n_t, \color{#E52B50}{\mu_j}) } \right)
\end{aligned}
\]</span></p>
<p>식(9.17), (9.18), (9.22)에서 적당히 파라미터에 색을 입혔다. 빨간색 파라미터들은 현재 설정된 파라미터라고 가정하고 이것을 통해 파란색 새로운 파리미터를 계산한다고 생각해보자. 그렇게 계산된 새로운 파라미터를 다시 빨간색에 대입하고 파란색 파라미터를 구해내는 식으로 진행하는 것이다.</p>
<p>하지만 이런 방식은 다분히 인위적인 것이어서 반복법이 해를 점진적으로 개선해줄 것이라는 보장이 없다. 현재까지는 일종의 궁여지책으로 보여지는데 일단 실험부터 해보도록 하자.</p>
<p>위 식에서 괄호로 묶인 부분을 간단히 <span class="math inline">\(\gamma_{nk}\)</span>로 다시 적고 실험해보자.</p>
<p><span class="math display">\[
\gamma_{nk}=\frac{ \color{#E52B50}{\pi_k} \text{Bin}(x_n \mid n_t, \color{#E52B50}{\mu_k})}{\sum_{j=1}^K \color{#E52B50}{\pi_j} \text{Bin}(x_n \mid n_t, \color{#E52B50}{\mu_j}) }  \tag{24}
\]</span></p>
<div class="cell" data-outputid="74c77ae3-7f30-441a-ed09-f7288de775e2">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> mu_0</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>pi <span class="op">=</span> pi_0</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 설명처럼 스무번 정도 반복해본다.</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">20</span>) :</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># E-step</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    Gamma <span class="op">=</span> np.array([ pi[k]<span class="op">*</span>binom.pmf(X, n_t, mu[k][<span class="dv">0</span>]) </span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(K) ]).transpose(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>).squeeze()</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    Gamma <span class="op">/=</span> Gamma.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># M-step</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    Nk <span class="op">=</span> Gamma.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> ((Gamma <span class="op">*</span> X).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>) <span class="op">/</span> (Nk<span class="op">*</span>n_t)).reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> Nk <span class="op">/</span> N</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"mu:"</span>)</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mu)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"pi: "</span>,pi)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>mu:
[[0.83811241]
 [0.3757192 ]]
pi:  [0.57154992 0.42845008]</code></pre>
</div>
</div>
<p>놀랍게도 수치적으로 구한 최적해와 거의 동일한 해로 수렴하는 것을 확인할 수 있다. 왜 이렇게 되는지 아직 명확하게 이해할 수는 없지만 식(9.17)을 보고 최대한 그럴듯한 이유를 생각해보기로 하자.</p>
<p>새로 정의한 <span class="math inline">\(\gamma_{nk}\)</span>는 현재 피라미터 <span class="math inline">\(\pi_k\)</span>, <span class="math inline">\(\mu_k\)</span>에서 데이터 <span class="math inline">\(x_n\)</span>이 <span class="math inline">\(k\)</span>번째 확률분포에서 발생할것 같은 정도를 나타낸다. 식을 보면 <span class="math inline">\(x_n\)</span>의 <span class="math inline">\(k\)</span>번 째 확률질량 함숫값을 모든 확률분포에서 구한 확률질량 함숫값의 합으로 나누고 있다. 따라서 <span class="math inline">\(k\)</span>번 째 확률분포의 <span class="math inline">\(x_n\)</span>에 대한 책임값responsibility이라고 하기도 한다. 무슨 이야긴지 실제 예를 보면서 이야기해보자.</p>
<div class="cell" data-outputid="1ee82e96-ff5f-48ca-a0eb-df497249df01">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> mu_0</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>pi <span class="op">=</span> pi_0</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Init. mu: "</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mu)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>Gamma <span class="op">=</span> np.array([ pi[k]<span class="op">*</span>binom.pmf(X, n_t, mu[k][<span class="dv">0</span>]) </span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(K) ]).transpose(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>).squeeze()</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>Gamma <span class="op">/=</span> Gamma.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Gamma: "</span>)</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Gamma)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Summation Gamma for K"</span>)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Gamma.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Init. mu: 
[[0.4]
 [0.3]]
Gamma: 
[[0.94668864 0.05331136]
 [0.55621735 0.44378265]
 [0.44620687 0.55379313]
 [0.82510466 0.17489534]
 [0.88007654 0.11992346]]
Summation Gamma for K
[1. 1. 1. 1. 1.]</code></pre>
</div>
</div>
<p><span class="math inline">\(\gamma_{nk}\)</span>에서 각 행은 <span class="math inline">\(x_n\)</span>에 대한 <span class="math inline">\(k\)</span>번 째 분포의 책임 정도를 나타내고 있다. 예를 들어 <span class="math inline">\(x_1\)</span>에 대해서는 1번 분포가 0.946정도로 책임을 지며 2번 분포는 0.053정도 책임을 진다는 것이다. <span class="math inline">\(x_2\)</span>에 대해서는 1번 분포가 0.556, 2번 분포가 0.443정도 책임을 진다. 다르게 말하면 현재 파라미터 상태에서는 <span class="math inline">\(x_1\)</span>은 95%정도는 1번 분포에서 나왔을것 같고 5%정도만 2번 분포에서 나왔을 것 같다는 말이 된다. 따라서 <span class="math inline">\(\gamma\)</span>의 모든 행을 <span class="math inline">\(k\)</span>에 대해 다 더하면 1이 되고 그렇기 때문에 식(22)에서 좌변이 <span class="math inline">\(N\)</span>이 되었던 것이다. 이렇게 다섯 개 데이터에 대해서 어느 분포에서 나왔을 것 같은지를 모두 계산했다.</p>
<p>이제 식(9.17)처럼 <span class="math inline">\(\gamma_{nk}\)</span>에 <span class="math inline">\(x_n\)</span>을 직접 곱하게 되면 <span class="math inline">\(x_n\)</span>값을 <span class="math inline">\(\gamma_{nk}\)</span> 비율대로 쪼개서 각 분포에 할당하게 될 것이다.</p>
<div class="cell" data-outputid="eb4a5545-e7d8-4158-e14d-f61be49b3cb3">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Gamma*X: "</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Gamma <span class="op">*</span> X)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Summation Gamma*X for K"</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>((Gamma <span class="op">*</span> X).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Gamma*X: 
[[9.46688636 0.53311364]
 [2.22486939 1.77513061]
 [1.3386206  1.6613794 ]
 [5.77573259 1.22426741]
 [7.04061236 0.95938764]]
Summation Gamma*X for K
[10.  4.  3.  7.  8.]</code></pre>
</div>
</div>
<p>위 코드로 계산 해보면 <span class="math inline">\(x_1=10\)</span>인데 1번 분포에 9.466…정도를 할당하고 2번 분포에 0.533… 정도를 할당하게 된다. 다른 모든 데이터도 이렇게 각 분포에 실제 값을 적당히 찢어서 할당하게 된다. 당연히 <span class="math inline">\(k\)</span>에 대해서 다 더하면 실제 데이터 값이 나오게 된다. 실제라면 데이터가 이렇게 쪼개져서 할당될 수 없고 두 분포 중 한쪽으로만 (hard 하게) 배분되어야 하지만 우리는 어느 분포로 할당해야할지 모르기 때문에 적당히 그럴듯 하게 쪼개서 (soft 하게) 할당한 것이라 이해하면 된다.</p>
<p>이렇게 대충 그럴것이라 생각되는 정도로 데이터를 각 분포에 할당했다면 완전 데이터 가능도에서 한 것처럼 각 분포에 할당된 데이터들을 가지고 평균을 계산해서 파라미터를 추정할 수 있는 것이다.</p>
<p><span class="math display">\[
\mu_k= \frac{\sum_{n=1}^N z_{nk} x_n}{n_t N_k} \tag{9}
\]</span></p>
<p>식(9)를 다시보면 <span class="math inline">\(k\)</span>번 째 분포에 할당된 데이터의 총합을 데이터의 개수를 나타내는 <span class="math inline">\(N_k\)</span>로 나누어 평균을 구하는 것을 알 수 있다. 추가로 <span class="math inline">\(n_t\)</span>를 더 나누는 것은 이항분포가 이미 <span class="math inline">\(n_t\)</span>번 베르누이 시행의 합산이기 때문이다. 불완전 데이터 세트에서 <span class="math inline">\(N_k\)</span>의 의미를 따져보면 <span class="math inline">\(k\)</span>번 째 분포에 할당될 것 같은 데이터의 개수이므로 3개, 4개 같이 딱 떨어지기 보다는 3.4와 같이 소수가 될 것이다.</p>
<div class="cell" data-outputid="2e938a24-667a-4a0f-de00-6d9bf2b07c2c">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>N_k <span class="op">=</span> (Gamma).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>,keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"N_k: "</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>( N_k  )</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Sum of N_k: "</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(N_k.<span class="bu">sum</span>())</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Sum of all data assigned to k-th distribution"</span>)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>( (Gamma<span class="op">*</span>X).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>,keepdims<span class="op">=</span><span class="va">True</span>)  )</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"mu after the first iteration"</span>)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>( (Gamma<span class="op">*</span>X).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>,keepdims<span class="op">=</span><span class="va">True</span>) <span class="op">/</span> (N_k<span class="op">*</span>n_t)  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>N_k: 
[[3.65429405 1.34570595]]
Sum of N_k: 
5.0
Sum of all data assigned to k-th distribution
[[25.84672129  6.15327871]]
mu after the first iteration
[[0.70729725 0.45725284]]</code></pre>
</div>
</div>
<p>코드를 통해 <span class="math inline">\(N_k\)</span>를 찍어보면 1번 분포에 3.65개, 2번 분포에 1.34개 정도 할당을 한것을 확인할 수 있다. 물론 다 더하면 5가 된다. 이제 적당히 분리된 데이터를 분포별로 다 더하고 <span class="math inline">\(n_t N_k\)</span>로 나누면 한번 반복이 완전히 완료되고 업데이트된 파라미터가 구해지게 된다.</p>
<p><code>[[0.70729725 0.45725284]]</code></p>
<p>한번 반복하여 업데이트 한 이 값을 눈여겨 봐두자.</p>
<p>이런 분석 과정을 통해 식(9.17), (9.18), (9.22)는 현재 파라미터 상태에서 그럴듯하게 새로운 파라미터를 추정하고 있음을 어렴풋이 알 수 있다. 그리고 돌이켜보면 <span class="math inline">\(\gamma_{nk}\)</span>를 구하는 과정과 앞서 알아본 야구 감독이 1선발 등판, 2선발 등판 상황에 확률을 부여하고 승률의 평균을 구하는 과정이 꽤 닮아있다는 느낌을 받을 것이다.</p>
</section>
</section>
</section>
</section>
<section id="em-알고리즘---3편" class="level1">
<h1>EM 알고리즘 - 3편</h1>
<section id="mathbfz의-사후확률" class="level2">
<h2 class="anchored" data-anchor-id="mathbfz의-사후확률"><span class="math inline">\(\mathbf{Z}\)</span>의 사후확률</h2>
<p>앞선 글에서 느닷없이 반복법을 들먹이면서 결과적으로는 해가 수렴함을 보였다. 이번 편에서는 이 현상을 평균 관점에서 해석해보도록 하자. 1편에서 평균을 이용하는 전체적인 전략을 이야기 했었다. 다시 한번 상기해보면 다음과 같다.</p>
<ol type="1">
<li><span class="math inline">\(\mathbf{Z}\)</span>를 모르기 때문에 <span class="math inline">\(\mathbf{Z}\)</span>가 가능한 모든 상태를 생각해보자.</li>
<li>그리고 그 상태들에 확률을 부여할 수 있다고 가정해보자.</li>
<li>그러면 모든 상태에 대해서 가능도 함숫값을 구하고 그렇게 구해진 함숫값들을 해당 <span class="math inline">\(\mathbf{Z}\)</span>에 부여된 확률을 이용해서 평균낼 수 있지 않을까?</li>
<li>그렇게만 할 수 있다면 그 가능도 함숫값의 평균을 최대화하는 파라미터를 찾을 수 있을 것이다.</li>
</ol>
<p>그리고 존재 가능한 모든 <span class="math inline">\(\mathbf{Z}\)</span>(우리 문제에서는 32가지)에 대해서 확률을 부여하는 것을 해결해야 한다고 했다. 우선 존재 가능한 모든 행렬 <span class="math inline">\(\mathbf{Z}\)</span>를 만들어보자.</p>
<div class="cell" data-outputid="498058ed-41ef-4470-977e-5c5ba500db24">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> possible_Z(rows, N):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> [rows <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array( <span class="bu">list</span>(itertools.product(<span class="op">*</span>R)) )</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co">#R = [[1,0],[0,1]]</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> np.eye(K)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>Zs <span class="op">=</span> possible_Z(R, N)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>Zs.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>(32, 5, 2)</code></pre>
</div>
</div>
<p>위 함수를 이용해서 존재 가능한 모든 <span class="math inline">\(\mathbf{Z}\)</span>를 만들 수 있다. 분포가 두개인 경우 서른 두가지 (5,2) 행렬이 만들어지며 몇 가지 확인해보면 다음과 같다.</p>
<div class="cell" data-outputid="1a6b9436-ca9c-492b-e590-bb472485405c">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Zs[<span class="dv">0</span>])</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Zs[<span class="dv">10</span>])</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Zs[<span class="dv">31</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1. 0.]
 [1. 0.]
 [1. 0.]
 [1. 0.]
 [1. 0.]]
[[1. 0.]
 [0. 1.]
 [1. 0.]
 [0. 1.]
 [1. 0.]]
[[0. 1.]
 [0. 1.]
 [0. 1.]
 [0. 1.]
 [0. 1.]]</code></pre>
</div>
</div>
<p>현재 <span class="math inline">\(\mathbf{z}\)</span>에 대한 정보는 전혀 없는 상태이므로 <span class="math inline">\(x\)</span>가 주어졌을 때 <span class="math inline">\(\mathbf{z}\)</span>에 대한 사후확률을 계산해야 한다. <span class="math inline">\(x\)</span>가 주어졌을 때<span class="math inline">\(z_k=1\)</span>일 확률을 <span class="math inline">\(p(z_k=1 \mid x)\)</span>로 쓰면 베이즈 정리에 의해 다음과 같다.</p>
<p><span class="math display">\[
\begin{aligned}
\gamma(z_k) = p(z_k=1 \mid x) &amp;= \frac{p(z_k=1)p(x \mid z_k =1)}{\sum_{j=1}^K p(z_j=1)p(x \mid z_j=1) } \\[5pt]
&amp;= \frac{\pi_k \text{Bin}(x \mid n_t, \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x \mid n_t, \mu_j)}
\end{aligned}
\]</span></p>
<p>두 번째 등호를 위해 식(9.10)과 (9.11)을 사용하였다.</p>
<p><span class="math display">\[
p(\mathbf{z}) = \prod_{k=1}^{K} \pi_k^{z_k} \tag{9.10}
\]</span></p>
<p><span class="math display">\[
p(x \mid \mathbf{z}) = \prod_{k=1}^K \text{Bin}(x \mid n_t, \mu_k)^{z_k} \tag{9.11}
\]</span></p>
<p>우리 문제에서 <span class="math inline">\(x\)</span>는 <span class="math inline">\(N\)</span>개가 있으므로 <span class="math inline">\(x\)</span>에 인덱스 <span class="math inline">\(n\)</span>을 도입하면</p>
<p><span class="math display">\[
\begin{aligned}
\gamma(z_{nk}) = p(z_{nk}=1 \mid x_n) &amp;= \frac{p(z_{nk}=1)p(x_n \mid  z_{nk} =1)}{\sum_{j=1}^K p(z_{nj}=1)p(x_n \mid z_{nj}=1) } \\[5pt]
&amp;= \frac{\pi_k \text{Bin}(x_n \mid n_t, \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x_n \mid n_t, \mu_j)}
\end{aligned}
\]</span></p>
<p>가 되므로 식(22)에서 구했던 <span class="math inline">\(\gamma_{nk}\)</span>가 <span class="math inline">\(\mathbf{z}\)</span>의 사후확률임을 알 수 있다. 따라서 벡터 변수 <span class="math inline">\(\mathbf{z}\)</span>에 대해서는 식(9.10)에 의해</p>
<p><span class="math display">\[
p(\mathbf{z}_n \mid \mathbf{x}_n)= \prod_{k=1}^K \left\{ \frac{\pi_k \text{Bin}(x_n \mid n_t, \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x_n \mid n_t, \mu_j)} \right\}^{z_{nk}}
\]</span></p>
<p>가 된다.</p>
<p>이제 모든 데이터를 고려한 <span class="math inline">\(\mathbf{Z}\)</span>에 대한 <span class="math inline">\(\mathbf{X}\)</span>를 조건으로 하는 사후확률은 <span class="math inline">\(x\)</span>를 독립적으로 샘플링했다는 가정하에서 다음처럼 쓸 수 있다.</p>
<p><span class="math display">\[
p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}) = \prod_{n=1}^N p( \mathbf{z}_n \mid x_n, \boldsymbol{\theta}) \tag{25}
\]</span></p>
<p>앞서 얻은 결과를 이용하면 최종적으로 다음과 같다.</p>
<p><span class="math display">\[
\begin{aligned}
p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta})
&amp;= \prod_{n=1}^N \prod_{k=1}^K \left\{ \frac{\pi_k \text{Bin}(x \mid n_t, \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x \mid n_t, \mu_j)} \right\}^{z_{nk}} \\
&amp;=  \prod_{n=1}^N \prod_{k=1}^K \gamma_{nk}^{z_{nk}}
\end{aligned} \tag{26}
\]</span></p>
<p>식(26)을 이용하면 모든 <span class="math inline">\(\mathbf{Z}\)</span> 행렬에 대해서 확률을 부여할 수 있다. 조금 후 자주 사용할 수식이기 때문에 우선 아래 코드로 구현해 놓는다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> set_posterior_Z(X, theta_old):</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> X</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    theta_old <span class="op">=</span> theta_old</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> posterior_Z(Z):</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="co">        EQ(26)</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co">        Z : (N,K)</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co">        X : (N,D)</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="co">        theta_old: (4,), (mu_1, mu_2, pi_1, pi_2)</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="co">        --------------------------------------</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="co">        N,D,K : gloval variables</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> theta_old[:K<span class="op">*</span>D].reshape(K,D)</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>        pi <span class="op">=</span> theta_old[<span class="op">-</span>K:]</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>        Gamma <span class="op">=</span> np.array([ pi[k]<span class="op">*</span>binom.pmf(X, n_t, mu[k][<span class="dv">0</span>]) </span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>                         <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(K) ]).transpose(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>).squeeze()</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>        Gamma <span class="op">/=</span> Gamma.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Gamma[Z<span class="op">==</span><span class="dv">1</span>].prod()</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> posterior_Z</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a><span class="co"># 현재 X와 theta_old를 조건으로 하는 Z의 확률분포를 세팅한다.</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>theta_old <span class="op">=</span> np.hstack((mu_0.flatten(), pi_0))</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>posterior_Z <span class="op">=</span> set_posterior_Z(X, theta_old)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>코드가 약간 복잡한데 조건으로 주어진 <span class="math inline">\(\mathbf{X}\)</span>, <span class="math inline">\(\boldsymbol{\theta}\)</span>를 함수 인자로 받지 않도록 하기 위해 클로져를 사용해서 함수를 만들어 리턴한다. 이제 <code>set_posterior_Z()</code>를 호출해서 사후확률을 구해주는 함수를 돌려 받으면 <span class="math inline">\(\mathbf{Z}\)</span>만 넘겨서 확률분포함수의 함숫값을 간편하게 구할 수 있다.</p>
<div class="cell" data-outputid="df36c343-ca17-4e67-9f81-0e039223af6e">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 이제 특정 Z에 대한 확률분포함숫값을 구할 수 있다.</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>posterior_Z(Zs[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>0.17061508495234065</code></pre>
</div>
</div>
</section>
<section id="완전-데이터-세트-가능도-함수의-평균" class="level2">
<h2 class="anchored" data-anchor-id="완전-데이터-세트-가능도-함수의-평균">완전 데이터 세트 가능도 함수의 평균</h2>
<p>이제 식(26)을 이용하여 완전 데이터 세트에 대한 가능도의 <span class="math inline">\(\mathbf{Z}\)</span>에 대한 평균 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>을 구할 수 있다. 구체적으로 계산하기 전에 개념적으로 앞선 반복법에서 고정하는 파라미터(빨간색)와 조정하는 파리미터(파란색)로 구분한 이유를 잠시 알아보기로 하자.</p>
<p>완전 데이터 세트의 가능도 함수 <span class="math inline">\(\ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})\)</span>의 평균을 <span class="math inline">\(\mathbf{Z}\)</span>에 대해서 구하려면 <span class="math inline">\(\mathbf{Z}\)</span>에 대한 확률분포를 사용하여 다음처럼 하면 된다.</p>
<p><span class="math display">\[
\sum_{\mathbf{Z}} p\left(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}\right) \ln p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta}) \tag{27}
\]</span></p>
<p>식(27)을 최대화 하려면 <span class="math inline">\(p\left(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}\right)\)</span>의 <span class="math inline">\(\boldsymbol{\theta}\)</span>는 고정하고 <span class="math inline">\(\ln p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta})\)</span>의 <span class="math inline">\(\boldsymbol{\theta}\)</span>를 조절해야 할 것이다. 식(27)을 <span class="math inline">\(\mathcal{Q}\)</span>라는 함수로 다시 적으면 다음과 같다.</p>
<p><span class="math display">\[
\mathcal{Q}\left(\boldsymbol{\theta}, \boldsymbol{\theta}^{\text{old}}\right) = \sum_{\mathbf{Z}} p\left(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}}\right) \ln p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta}) \tag{9.30}
\]</span></p>
<p>식(9.30)에서 <span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>는 <span class="math inline">\(\mathbf{Z}\)</span>의 사후확률분포를 구하기 위한 고정된 현재 파라미터이고, <span class="math inline">\(\boldsymbol{\theta}\)</span>는 <span class="math inline">\(\mathcal{Q}\left(\boldsymbol{\theta}, \boldsymbol{\theta}^{\text{old}}\right)\)</span>를 최대화 하기 위해 우리가 조정하는 파라미터이다. 이렇게 완전 데이터 세트 가능도 함수의 평균을 구하는 과정에서 이미 지정된 파라미터와 최적화 될 파라미터가 자연스럽게 구분되게 된다. 이것으로 반복법에서 변수를 느닷없이 두 부류로 나눈 것이 <span class="math inline">\(\mathbf{Z}\)</span>의 사후확률을 구하는 것과 완전 데이터 세트의 가능도 함수 평균을 최대화하는 과정과 관계 있다는 것을 어렴풋이 알 수 있다.</p>
<section id="수치적-방법-반복법에-대한-당위성" class="level3">
<h3 class="anchored" data-anchor-id="수치적-방법-반복법에-대한-당위성">수치적 방법: 반복법에 대한 당위성</h3>
<p>앞서 변수를 두 부류로 나눈것에 대한 이유를 대강 알아보았으니 이번에는 왜 반복법을 사용했는가에 대한 이유를 알아보자. 식(9.30)을 최대화 시키는 <span class="math inline">\(\boldsymbol{\theta}\)</span>를 찾으면 되므로 여기서도 수치적 방법을 동원해서 해를 찾아보자. 우선 <span class="math inline">\(\mathcal{Q}\)</span> 함수를 준비한다. 이미 모든 부속 함수를 만들어 놓았으므로 쉽게 코딩할 수 있다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Q(theta, theta_old):</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co">    theta     : (4,), (mu_1, mu_2, pi_1, pi_2)</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co">    theta_old : (4,), (mu_1, mu_2, pi_1, pi_2)</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="co">    -------------------------------------------</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="co">    gloval variables</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="co">    X  : (N,D) </span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Zs : (K^N, N, K)</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co">    N,D,K</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># K = Zs.shape[2]</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    p_Z_given_X_and_theta_old <span class="op">=</span> set_posterior_Z(X, theta_old)</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    ret <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Z_i <span class="kw">in</span> Zs : <span class="co"># 모든 Z에 대해서 평균을 낸다.</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># eq (9.30)</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">+=</span> p_Z_given_X_and_theta_old(Z_i)<span class="op">*</span>loglikelihood_XZ(theta, X, Z_i)</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret    </span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a><span class="co"># scipy.optimize.minimize 사용을 위해 -Q로 만들어 놓는다.</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> negative_Q(theta, theta_old):</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>Q(theta, theta_old) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>이제 초기값을 설정하고 이전에 만들어 둔 제약조건을 사용해서 최적화 함수를 호출한다.</p>
<div class="cell" data-outputid="eef46a00-54f0-4892-f977-42151bf20db9">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 파라미터를 펼쳐서 1차원 배열 하나로 만든다.</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.hstack((mu_0.flatten(), pi_0))</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.copy(theta)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>theta_old <span class="op">=</span> np.copy(theta)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Init. input:'</span>, x)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> minimize(negative_Q, x, args<span class="op">=</span>(theta_old), method<span class="op">=</span><span class="st">'SLSQP'</span>, </span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>               bounds<span class="op">=</span>bounds, constraints<span class="op">=</span>cons,</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>               options<span class="op">=</span>{<span class="st">'iprint'</span>: <span class="dv">2</span>, <span class="st">'disp'</span>: <span class="va">True</span>})</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res)</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"sum pi_k:"</span>,res.x[<span class="dv">2</span>:].<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Init. input: [0.4 0.3 0.5 0.5]
  NIT    FC           OBJFUN            GNORM
    1     6     2.389727E+01     4.848931E+01
    2    13     1.906314E+01     3.115227E+01
    3    20     1.754121E+01     2.277992E+01
    4    27     1.648351E+01     1.696680E+01
    5    34     1.624252E+01     1.531351E+01
    6    41     1.595074E+01     1.074425E+01
    7    47     1.570851E+01     9.368190E+00
    8    53     1.556181E+01     6.907221E+00
    9    59     1.555421E+01     7.045966E+00
   10    65     1.555393E+01     7.073587E+00
   11    71     1.555392E+01     7.071202E+00
Optimization terminated successfully.    (Exit mode 0)
            Current function value: 15.553919769048395
            Iterations: 11
            Function evaluations: 71
            Gradient evaluations: 11
     fun: 15.553919769048395
     jac: array([-1.69980526e-03,  4.49538231e-04, -4.99988914e+00, -5.00030005e+00])
 message: 'Optimization terminated successfully.'
    nfev: 71
     nit: 11
    njev: 11
  status: 0
 success: True
       x: array([0.70728766, 0.45726058, 0.73087497, 0.26912503])
sum pi_k: 1.0</code></pre>
</div>
</div>
<p>성공적으로 최적화가 수행되었고 구해진 해는 아래와 같다.</p>
<p><code>x: array([0.70728766, 0.45726058, 0.73087497, 0.26912503])</code></p>
<p>1편과 2편에서 구한 수치해와는 조금 차이가 있다. 첫 두 파라미터는 0.8, 0.45 근처값이 최적해인데 구해진 해는 0.707, 0.457로 최적해로 수렴하다 만것같은 느낌이 든다. 이런 결과가 나온 이유는 여기서 우리가 최적화 시킨 함수는 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>이 아니고 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>이기 때문이다. 가능도 함수를 직접 최적화 시키지 못하고 그 평균을 최적화 시켰기 때문에 우리가 원하는 최적점까지 가지 못한 것이다.</p>
<p>2편에서 반복법을 설명할 때 한 번 반복 후 업데이트 된 해를 눈여겨 봐두자고 했었는데 구해진 해가 그 해와 아주 비슷한 것을 알 수 있다. 2편 반복법에서 첫 번째로 업데이트된 해를 다시보자.</p>
<p><code>[[0.70729725 0.45725284]]</code></p>
<p>거의 같은 해라는 것을 알 수 있을 것이다. 이는 우연이 아니며 나중에 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>를 직접 미분하여 구한 해가 식(9.17), (9.22)와 일치하는 것을 알아보도록 할것이다.</p>
<p>그렇기에 구해진 해를 <code>theta_old</code>로 재설정하고 최적화를 다시 수행하기를 반복하면 원하는 최적해로 수렴할 수 있을 것 같다는 예상을 할 수 있다.</p>
<div class="cell" data-outputid="7223bef8-9ea0-4782-a887-f39144802b8b">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 파라미터를 펼쳐서 1차원 배열 하나로 만든다.</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.hstack((mu_0.flatten(), pi_0))</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.copy(theta)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>theta_old <span class="op">=</span> np.copy(theta)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Init. input:'</span>, x)</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">20</span>) :</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> minimize(negative_Q, x, args<span class="op">=</span>(theta_old), method<span class="op">=</span><span class="st">'SLSQP'</span>, </span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>                bounds<span class="op">=</span>bounds, constraints<span class="op">=</span>cons,</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>                options<span class="op">=</span>{<span class="st">'iprint'</span>: <span class="dv">0</span>, <span class="st">'disp'</span>: <span class="va">True</span>})</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(res.x)</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.copy(res.x)</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    theta_old <span class="op">=</span> np.copy(res.x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Init. input: [0.4 0.3 0.5 0.5]
[0.70728766 0.45726058 0.73087497 0.26912503]
[0.8375278  0.37398245 0.57384792 0.42615208]
[0.83806643 0.37565554 0.57195203 0.42804797]
[0.83811421 0.37567489 0.57181128 0.42818872]</code></pre>
</div>
</div>
<p>결과를 보면 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 직접 미분하여 구한 결과인 식(9.17), (9.18), (9.22)를 반복적으로 적용하여 구한 해로 수렴하는 듯 보인다.</p>
<p>지금까지 과정을 다시한번 정리해보자.</p>
<ol type="1">
<li><p>2편에서는 <span class="math inline">\(\mathbf{z}\)</span>에 대한 정보가 없기 때문에 <span class="math inline">\(\mathbf{z}\)</span>를 주변화 시켜서 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 구하고 이를 직접 수치적으로 또 해석적으로 최적화 시켰다.</p></li>
<li><p>해석적인 과정에서 구해진 해는 닫힌 형식이 아니라서 궁여지책으로 반복법을 제안하였고 신기하게도 그 방법이 수치해로 수렴하는 것을 확인하였다.</p></li>
<li><p>이번에는 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>를 계산하고 이를 최적화하였다. <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>를 유도하는 과정에서 고정해야하는 파라미터와 조절해야하는 파라미터를 자연스럽게 분리할 수 있었다.</p></li>
<li><p>3번에서 최적화 결과는 만족스럽지 못했는데 2번에서 반복법을 여기서도 그대로 적용해보니 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>에 대한 최적해가 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>의 최적해로 수렴하는 듯 보였다.</p></li>
</ol>
<p>현재까지 실험으로 미뤄보면 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>를 반복적으로 최대화 시킨 결과가 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>의 최적해로 수렴한다고 결론 내릴 수 있다. 우리의 궁극적인 목적은 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 최대화 시키는 것이기 때문에 결국 목적이 달성된 것이다.</p>
</section>
<section id="해석적-방법-2" class="level3">
<h3 class="anchored" data-anchor-id="해석적-방법-2">해석적 방법</h3>
<p>1, 2편과 마찬가지로 이번에는 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>에 대한 해석적 방법을 고려해보자. 그러기 위해서 먼저 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>를 우리 문제에 대해서 목적함수로 정식화 해야 한다. 그 후 정식화된 목적함수를 미분할 것이다.</p>
<section id="목적함수-정식화" class="level4">
<h4 class="anchored" data-anchor-id="목적함수-정식화">목적함수 정식화</h4>
<p><span class="math inline">\(x_n\)</span>이 독립적으로 샘플링 되었다는 독립성 가정에 의해 앞서 유도한 다음식을 보자.</p>
<p><span class="math display">\[
p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}) = \prod_{n=1}^N p( \mathbf{z}_n \mid x_n, \boldsymbol{\theta}) \tag{25}
\]</span></p>
<p>식(25)는 인덱스 <span class="math inline">\(n\)</span>에 대해 다 곱해진 식이므로 <span class="math inline">\(\{\mathbf{z}_n\}\)</span>들 끼리 인수분해가 되어 있는 식이다. 따라서 행렬 <span class="math inline">\(\mathbf{Z}\)</span>에 대한 확률분포를 구성하는 행벡터 <span class="math inline">\(\mathbf{z}_n\)</span>들은 모두 독립이다. 이런 이유로 <span class="math inline">\(\mathbf{Z}\)</span>의 사후확률분포에서 <span class="math inline">\(z_{nk}\)</span>의 기댓값은 <span class="math inline">\(z_{nk}\)</span>가 속하는 벡터 <span class="math inline">\(\mathbf{z}_n\)</span>에 대해서만 기대값을 고려하면 된다. <span class="math inline">\(z_{nk}\)</span>의 기댓값은 다음처럼 벡터 <span class="math inline">\(\mathbf{z}_n\)</span>의 합산에 의해 주어지게 된다.</p>
<p><span class="math display">\[
\begin{aligned}
\mathbb{E}_{\mathbf{z}_n \mid x_n} [ z_{nk} ]
&amp;= \sum_{\mathbf{z}_n}  z_{nk} \cdot p(\mathbf{z}_n \mid x_n) \\[5pt]
&amp;= \sum_{\mathbf{z}_n}  z_{nk} \frac{p(x_n, \mathbf{z}_n)}{p(x_n)} \\[5pt]
&amp;= \sum_{\mathbf{z}_n}   \frac{z_{nk} \cdot p(x_n, \mathbf{z}_n)}{p(x_n)} \\[5pt]
&amp;= \frac{ \sum_{\mathbf{z}_n}  z_{nk} \cdot p(x_n, \mathbf{z}_n)}{ \sum_{\mathbf{z}_n}  p(x_n, \mathbf{z}_n)} \\
\end{aligned} \tag{9.39-1}
\]</span></p>
<p>위 식에서 <span class="math inline">\(\sum_{\mathbf{z}_n}\)</span>은 <span class="math inline">\(\mathbf{z}_n\)</span> 벡터가 가질 수 있는 모든 벡터들에 대해서 합산하라는 뜻이다. 데이터 <span class="math inline">\(x_n\)</span>하나에 대응되는 <span class="math inline">\(\mathbf{z}_n\)</span> 벡터 <span class="math inline">\(N\)</span>개에 대해서 합산하라는 뜻이 아님을 주의해야 한다. 예를들어 <span class="math inline">\(K=2\)</span>이면 <span class="math inline">\(\mathbf{z}_n = (0,1)^{\text{T}}\)</span>, <span class="math inline">\(\mathbf{z}_n = (1,0)^{\text{T}}\)</span>인 두 경우에 대해서 합산하라는 뜻이다. <span class="math inline">\(p(x_n, \mathbf{z}_n)\)</span>은 아래와 같으므로</p>
<p><span class="math display">\[
p(x_n, \mathbf{z}_n) = \prod_{k=1}^K \left[ \pi_k \text{Bin}(x_n \mid \mu_k) \right]^{z_{nk}}
\]</span></p>
<p>위 식을 대입하면</p>
<p><span class="math display">\[
\begin{aligned}
\mathbb{E}_{\mathbf{z}_n \mid x_n} [ z_{nk} ]
&amp;= \frac{ \sum_{\mathbf{z}_n}  z_{nk} \cdot p(x_n, \mathbf{z}_n)}{ \sum_{\mathbf{z}_n}  p(x_n, \mathbf{z}_n)} \\[5pt]
&amp;= \frac{ \sum_{\mathbf{z}_n} z_{nk} \prod_{k'=1}^K [\pi_{k'} \text{Bin}(x_n \mid \mu_{k'})]^{z_{nk'}}}{ \sum_{\mathbf{z}_n} \prod_{j=1}^K [\pi_j \text{Bin}(x_n \mid \mu_j)]^{z_{nj}} }
\end{aligned} \tag{9.39-2}
\]</span></p>
<p>가 된다. 식(9.39-2)에서 분모를 보자. 모든 <span class="math inline">\(\mathbf{z}_n\)</span>에 대해서 <span class="math inline">\(\prod_{j=1}^K\)</span>를 계산하고 있는데 <span class="math inline">\(\mathbf{z}_n\)</span>은 오직 한 자리만 1인 원핫 벡터이므로 결국 분모는 <span class="math inline">\(\sum_{j=1}^K\)</span>가 된다. 분자도 같은 이유로 <span class="math inline">\(K\)</span>항이 합산되는데 <span class="math inline">\(z_{nk}\)</span>가 곱해지기 때문에 <span class="math inline">\(k\)</span>번 째 항만 남고 나머지는 0이 곱해져 다 사라지게 된다. 따라서 최종적으로 다음과 같다.</p>
<p><span class="math display">\[
\begin{aligned}
\mathbb{E}_{\mathbf{z}_n \mid x_n} [ z_{nk} ]
&amp;= \frac{ \sum_{\mathbf{z}_n} z_{nk} \prod_{k'=1}^K [\pi_{k'} \text{Bin}(x_n \mid \mu_{k'})]^{z_{nk'}}}{ \sum_{\mathbf{z}_n} \prod_{j=1}^K [\pi_j \text{Bin}(x_n \mid \mu_j)]^{z_{nj}} } \\[5pt]
&amp;= \frac{\pi_k \text{Bin}(x_n \mid \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x_n \mid \mu_j)} = \gamma(z_{nk})
\end{aligned} \tag{9.39}
\]</span></p>
<p>주어진 결과는 이전에 계산한 책임값 <span class="math inline">\(\gamma_{nk}\)</span>가 된다.</p>
<p>이제 식(9.36)에 기대값을 취해 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>를 직접 구할 수 있다.</p>
<p><span class="math display">\[
\begin{aligned}
\mathbb{E}_{\mathbf{Z}} \left[  \ln p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta}) \right]
&amp;= \mathbb{E}_{\mathbf{Z}} \left[ \sum_{n=1}^N \sum_{k=1}^K z_{nk} \{ \ln \pi_k + \ln \text{Bin}(x_n \mid  n_t, \mu_k) \} \right] \\
&amp;= \sum_{n=1}^N \sum_{k=1}^K \mathbb{E}_{\mathbf{Z}} [ z_{nk} ] \{ \ln \pi_k + \ln \text{Bin}(x_n \mid  n_t, \mu_k) \} \\
&amp;= \sum_{n=1}^N \sum_{k=1}^K \mathbb{E}_{\mathbf{z}_n \mid x_n} [ z_{nk} ] \{ \ln \pi_k + \ln \text{Bin}(x_n \mid  n_t, \mu_k) \} \\
&amp;= \sum_{n=1}^N \sum_{k=1}^K \gamma(z_{nk}) \{ \ln \pi_k + \ln \text{Bin}(x_n \mid  n_t, \mu_k) \}
\end{aligned} \tag{9.40}
\]</span></p>
<p>식(9.40)에서 기댓값의 선형성이 사용되었다. 아래 코드로 구현 해두도록 하자.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> E_Z_loglikelihood_XZ(theta, X) :</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co">    EQ (9.40)</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="co">    theta     : (4,), (mu_1, mu_2, pi_1, pi_2)</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="co">    -------------------------------------------</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="co">    gloval variables</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="co">    theta_old : (4,), (mu_1, mu_2, pi_1, pi_2)</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="co">    N,D,K </span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># N, D = X.shape[0], X.shape[1]</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> theta[:K<span class="op">*</span>D].reshape(K,D)</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> theta[<span class="op">-</span>K:]</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    mu_old <span class="op">=</span> theta_old[:K<span class="op">*</span>D].reshape(K,D)</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    pi_old <span class="op">=</span> theta_old[<span class="op">-</span>K:]</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 전역변수 theta_old로 계산하는 것 주의!!</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>    Gamma <span class="op">=</span> np.array([ pi_old[k]<span class="op">*</span>binom.pmf(X, n_t, mu_old[k][<span class="dv">0</span>]) </span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(K) ]).transpose(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>).squeeze()</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>    Gamma <span class="op">/=</span> Gamma.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>    binom_x_given_mu_k <span class="op">=</span> np.array([ binom.pmf(X, n_t, mu[k][<span class="dv">0</span>]) </span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a>                                <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(K) ]).transpose(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>).squeeze()</span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (Gamma<span class="op">*</span>(np.log(pi<span class="op">+</span><span class="fl">1.0e-8</span>).reshape(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> np.log(binom_x_given_mu_k<span class="op">+</span><span class="fl">1.0e-8</span>))).<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>식(9.30)과 (9.40)은 궁극적으로 같은 식이다. 아래 코드로 두 함수의 값을 찍어보면 같은 값이 찍히는 것을 확인할 수 있다.</p>
<div class="cell" data-outputid="d0a1f79b-49c6-4f15-a947-b78cbb1ca6a7">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.hstack((mu_0.flatten(), pi_0))</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>theta_old <span class="op">=</span> theta</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>( <span class="st">"Q(theta, theta_old) : </span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(Q(theta, theta_old)) )</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>( <span class="st">"Ez[ln p(X,Z|theta)] : </span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(E_Z_loglikelihood_XZ(theta,  X)) )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Q(theta, theta_old) : -23.897270
Ez[ln p(X,Z|theta)] : -23.897270</code></pre>
</div>
</div>
<p>이제 정식화가 끝났으니 미분하여 0으로 두고 최적해를 찾는 일만 남았다.</p>
</section>
<section id="목적함수-미분" class="level4">
<h4 class="anchored" data-anchor-id="목적함수-미분">목적함수 미분</h4>
<p>식(9.36)과 식(9.40)에서 차이점은 <span class="math inline">\(z_{nk}\)</span>가 <span class="math inline">\(\gamma(z_{nk})\)</span>로 변한것 밖에 없으므로 식(9.40)을 <span class="math inline">\(\mu_k\)</span>로 미분하고 0으로 두어 최적해를 구하는 과정은 식(9.36)에서 계산한 것과 동일하며 최종적으로 다음처럼 될것이다.</p>
<p><span class="math display">\[
\mu_k = \frac{\sum_{n=1}^N \gamma(z_{nk}) x_n }{n_t \sum_{n=1}^N \gamma(z_{nk}) } \tag{28}
\]</span></p>
<p><span class="math inline">\(\gamma(z_{nk})\)</span>는 다음과 같으므로</p>
<p><span class="math display">\[
\gamma(z_{nk}) = \frac{\pi_k \text{Bin}(x_n \mid n_t, \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x_n \mid n_t, \mu_j)}
\]</span></p>
<p>식(28)에 대입하면</p>
<p><span class="math display">\[
\mu_k = \frac{\sum_{n=1}^N \left( \dfrac{\pi_k \text{Bin}(x_n \mid n_t, \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x_n \mid n_t, \mu_j)} \right) x_n }{n_t \sum_{n=1}^N \left( \dfrac{\pi_k \text{Bin}(x_n \mid n_t, \mu_k)}{\sum_{j=1}^K \pi_j \text{Bin}(x_n \mid n_t, \mu_j)} \right) }  \tag{29}
\]</span></p>
<p>가 된다. 식(29)는 식(9.17)과 정확히 동일한 식이다.</p>
<p><span class="math inline">\(\pi_k\)</span>로 미분하는 과정도 역시 동일하게 식(5), (6)과 유사한 다음 두식을 얻을 수 있다.</p>
<p><span class="math display">\[
\sum_{n}^N \left(  \frac{\gamma(z_{nk})}{\pi_k}\right) + \lambda = 0 \tag{30}
\]</span></p>
<p><span class="math display">\[
\sum_{j=1}^K \pi_j -1 = 0 \tag{31}
\]</span></p>
<p>식(30), (31)을 연립해서 풀면</p>
<p><span class="math display">\[
\pi_k = \frac{N_k}{N} \tag{32}
\]</span></p>
<p>를 얻을 수 있는데 이 역시 식(9.22)와 동일한 식이다.</p>
<p>이 과정을 통해 알 수 있는 사실은 식(9.17), (9.22)와 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>를 미분하여 얻은 식 (29), (32)는 완전히 동일하다는 점이고, 더욱 중요한 사실은 두 식들이 모양은 같지만 두 번째 구한 식(29), (32)들은 닫힌 형식의 해라는 점이다. 왜냐하면 식(29), (32)에서 우변에 나타난 <span class="math inline">\(\mu_k\)</span>, <span class="math inline">\(\pi_k\)</span>들은 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>를 구성할 때 미리 지정한 파라미터들이기 때문이다.</p>
<p>그렇기 때문에 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 미분하여 얻은 최적해인 식(9.17), (9.22)를 통해서는 원칙적으로 어떤 해도 구할 수 없었지만 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}} \left[ \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) \right]\)</span>를 미분하여 찾은 최적해는 그것이 비록 만족스런 최적해가 아닐지라도 적어도 계산은 가능해 진 것이다. 즉 <span class="math inline">\(\mu_k\)</span>, <span class="math inline">\(\pi_k\)</span>를 임의로 지정하고 식(29), (32)를 통해 개선된 파라미터를 계산할 수 있는 것이다. 하지만 이 한번의 업데이트를 통해서 만족스런 해에 도달할 수 없다는 것을 앞선 수치과정으로 확인했다. 아울러 만족스런 해를 얻기 위해서는 식(29), (32)를 반복적으로 시도해야 한다는 사실도 앞선 수치적 방법을 통한 실험으로 알 수 있었다.</p>
<p>이제 우리에게 남은 마지막 의문은 왜 반복법을 사용하면 해가 수렴하는가 하는 것이다.</p>
</section>
</section>
</section>
</section>
<section id="em-알고리즘---4편" class="level1">
<h1>EM 알고리즘 - 4편</h1>
<section id="반복법이-수렴하는-이유" class="level2">
<h2 class="anchored" data-anchor-id="반복법이-수렴하는-이유">반복법이 수렴하는 이유</h2>
<p>2편과 3편에 걸쳐 제안하고 실험한 반복법의 해가 $ ( )$의 최대값으로 수렴하는 이유를 알아보기 위해 다음 식(9.70)과 같은 분해를 알아보자.</p>
<p><span class="math display">\[
\ln p(\mathbf{X} \mid \boldsymbol{\theta})= \mathcal{L}(q, \boldsymbol{\theta}) + KL(q \,||\, p) \tag{9.70}
\]</span></p>
<p>식 (9.70)에서 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>가 무엇인지 유도하기 위해</p>
<p><span class="math display">\[
\ln p(\mathbf{X} \mid \boldsymbol{\theta}) = \ln \sum_{\mathbf{Z}}  p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})
\]</span></p>
<p>에서 우변에 먼저 임의의 <span class="math inline">\(q(\mathbf{Z})\)</span>를 도입하자.</p>
<p><span class="math display">\[
\begin{aligned}
\ln \sum_{\mathbf{Z}} p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})
&amp;= \ln \left\{ \sum_{\mathbf{Z}} q(\mathbf{Z}) \frac{p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})}{q(\mathbf{Z})} \right\} \\[5pt]
&amp; \ge \sum_{\mathbf{Z}} q(\mathbf{Z})  \ln \left\{ \frac{p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})}{q(\mathbf{Z})} \right\} \qquad \because \text{Jensen's inequality}\\[5pt]
&amp;=  \mathcal{L}(q, \boldsymbol{\theta})
\end{aligned}
\]</span></p>
<p>위 식에서 부등식은 옌센 부등식으로 로그 함수는 오목함수라서 <span class="math inline">\(\mathbb{E}[f(x)] \le f(\mathbb{E}[x])\)</span>가 되어서 성립한다. <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>는 다음처럼 정의되고 정의 그 자체로 최적화 하고자 하는 파라미터를 조건으로 하는 데이터의 로그 가능도 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>의 하한이 됨을 알 수 있다.</p>
<p><span class="math display">\[
\mathcal{L}(q, \boldsymbol{\theta}) = \sum_{\mathbf{Z}} q(\mathbf{Z})  \ln \left\{ \frac{p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})}{q(\mathbf{Z})} \right\} \tag{9.71}
\]</span></p>
<p>계속해서 식(9.70)을 완성해보자. 완전 데이터 데이터 세트의 확률분포는</p>
<p><span class="math display">\[
p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})  = p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}) p(\mathbf{X} \mid \boldsymbol{\theta})
\]</span></p>
<p>이며, 로그를 취하면</p>
<p><span class="math display">\[
\ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})  = \ln p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}) + \ln p(\mathbf{X} \mid \boldsymbol{\theta}) \tag{9.73}
\]</span></p>
<p>식(9.73)을 식(9.71)에 대입하면</p>
<p><span class="math display">\[
\begin{aligned}
\mathcal{L}(q, \boldsymbol{\theta}) &amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln \left\{ \frac{p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta})}{q(\mathbf{Z})} \right\} \\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \left\{ \ln p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta}) - \ln q(\mathbf{Z})\right\} \\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \left\{ \ln p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}) + \ln p(\mathbf{X} \mid \boldsymbol{\theta})  - \ln q(\mathbf{Z}) \right\} \qquad \because \text{eq(9.73)} \\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}) +  \sum_{\mathbf{Z}} q(\mathbf{Z})\ln p(\mathbf{X} \mid \boldsymbol{\theta}) - \sum_{\mathbf{Z}} q(\mathbf{Z})\ln q(\mathbf{Z}) \\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \left\{ \ln p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}) - \ln q(\mathbf{Z}) \right\} + \sum_{\mathbf{Z}} q(\mathbf{Z})\ln p(\mathbf{X} \mid \boldsymbol{\theta}) \\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z})  \ln \left\{ \frac{\ln p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta})}{\ln q(\mathbf{Z}) } \right\} + \sum_{\mathbf{Z}} q(\mathbf{Z})\ln p(\mathbf{X} \mid \boldsymbol{\theta}) \\[5pt]
&amp;= -KL(q \,||\, p) + \ln p(\mathbf{X} \mid \boldsymbol{\theta})\sum_{\mathbf{Z}} q(\mathbf{Z}) \qquad \because \sum_{\mathbf{Z}} q(\mathbf{Z}) = 1 \\[5pt]
&amp;= -KL(q \,||\, p) + \ln p(\mathbf{X} \mid \boldsymbol{\theta})
\end{aligned}
\]</span></p>
<p><span class="math inline">\(-KL(q \, || \, p)\)</span>를 이항하면 식(9.70)이 완성된다. 따라서 식(9.70)에서 <span class="math inline">\(KL(q \, || \, p)\)</span>는 식(9.72)와 같다.</p>
<p><span class="math display">\[
KL(q \,||\, p) = - \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln \frac{p(\mathbf{Z} \mid \mathbf{X},\boldsymbol{\theta})}{ q(\mathbf{Z}) } \tag{9.72}
\]</span></p>
<p>아니면 대수적으로 아래처럼 <span class="math inline">\(\ln (\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 직접 분해할 수 도 있다.</p>
<p><span class="math display">\[
\begin{aligned}
\ln p(\mathbf{X} \mid \boldsymbol{\theta})
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln p(\mathbf{X} \mid \boldsymbol{\theta})  \qquad \because \sum_{\mathbf{Z}} q(\mathbf{Z}) = 1\\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln \frac{p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta})}{p(\mathbf{Z} \mid \mathbf{X},\boldsymbol{\theta})} \qquad \because p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})  = p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}) p(\mathbf{X} \mid \boldsymbol{\theta}) \\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln \left\{ \frac{p(\mathbf{Z},\mathbf{Z} \mid \boldsymbol{\theta})}{q(\mathbf{Z})}  \frac{q(\mathbf{Z})}{p(\mathbf{Z} \mid \mathbf{X},\boldsymbol{\theta})} \right\} \\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \left\{ \ln \frac{p(\mathbf{X},\mathbf{Z} \mid \boldsymbol{\theta})}{q(\mathbf{Z})} + \ln \frac{q(\mathbf{Z})}{p(\mathbf{Z} \mid \mathbf{X},\boldsymbol{\theta})} \right\} \\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln \frac{p(\mathbf{X},\mathbf{z} \mid \boldsymbol{\theta})}{q(\mathbf{Z})} + \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln \frac{q(\mathbf{Z})}{p(\mathbf{z}\,|\,\mathbf{x},\boldsymbol{\theta})} \\[5pt]
&amp;= \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln \frac{p(\mathbf{X},\mathbf{Z}\mid \boldsymbol{\theta})}{q(\mathbf{Z})} - \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln \frac{p(\mathbf{Z} \mid \mathbf{Z},\boldsymbol{\theta})}{ q(\mathbf{Z}) } \\[5pt]
&amp;= \mathcal{L}(q, \boldsymbol{\theta}) + KL(q \,||\, p)
\end{aligned} \tag{9.70}
\]</span></p>
<p>정리를 위해 식(9.70), (9.71), (9.72)를 함께 다시 써보면</p>
<p><span class="math display">\[
\ln p(\mathbf{X} \mid \boldsymbol{\theta})= \mathcal{L}(q, \boldsymbol{\theta}) + KL(q \,||\, p) \tag{9.70}
\]</span></p>
<p><span class="math display">\[
\mathcal{L}(q, \boldsymbol{\theta}) = \sum_{\mathbf{Z}} q(\mathbf{Z})  \ln \left\{ \frac{p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})}{q(\mathbf{Z})} \right\} \tag{9.71}
\]</span></p>
<p><span class="math display">\[
KL(q \,||\, p) = - \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln \frac{p(\mathbf{Z} \mid \mathbf{X},\boldsymbol{\theta})}{ q(\mathbf{Z}) } \tag{9.72}
\]</span></p>
<p>위 식은 <span class="math inline">\(\mathbf{X}\)</span>에 대한 로그 가능도 함수가 임의로 선택된 <span class="math inline">\(q(\mathbf{Z})\)</span>에 대해서 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>와 <span class="math inline">\(KL(q \,||\, p)\)</span>로 분해됨을 알려준다. <span class="math inline">\(q(\mathbf{Z})\)</span>란 <span class="math inline">\(\mathbf{Z}\)</span>에 대한 분포로 우리는 <span class="math inline">\(\mathbf{Z}\)</span>에 대해 아는 것이 없으므로 임의로 선택해야 하는 분포이다. 그런데 <span class="math inline">\(q(\mathbf{Z})\)</span>를 잘 선택하면 <span class="math inline">\(KL(q \,||\, p)=0\)</span>으로 만들어 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})=\mathcal{L}(q, \boldsymbol{\theta})\)</span> 로 만들 수 있다. 바로 <span class="math inline">\(p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta})\)</span>로 선택하면 식(9.72)에서 <span class="math inline">\(KL(q \,||\, p)=0\)</span>이 됨을 알 수 있다. 식(9.70)을 구체적으로 시각화 해보자. 그림을 그리기위해 현재 우리가 가지고 있는 파라미터를 <span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>라 표시하고 설정해둔다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>theta_old <span class="op">=</span> np.hstack((mu_0.flatten(), pi_0))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 하한 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>와 <span class="math inline">\(\text{KL}(q\,||\,p)\)</span>로 나눠 그리기 위해서 식(9.71)을 로그 성질을 이용하여 풀어 적어보면</p>
<p><span class="math display">\[
\mathcal{L}(q, \boldsymbol{\theta}) = \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) - \sum_{\mathbf{Z}} q(\mathbf{Z}) \ln q(\mathbf{Z}) \tag{33}
\]</span></p>
<p>위 식에서 두 번째 항은 <span class="math inline">\(q(\mathbf{Z})\)</span>의 엔트로피라는 것을 알 수 있다. 먼저 두번째 항을 계산하기 위해 임의의 <span class="math inline">\(q(\mathbf{Z})\)</span>를 넘겨받아 엔트로피를 계산하는 함수를 만든다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> entropy_Z(q) :</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="co">    주어진 확률 분포 q(Z)에 대해서 엔트로피를 계산한다.</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co">    q : Z를 받아서 확률분포를 계산하는 임의의 함수</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    entropy <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Z_i <span class="kw">in</span> Zs :</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>        pz <span class="op">=</span> q(Z_i)</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>        entropy <span class="op">+=</span> pz<span class="op">*</span>np.log(pz<span class="op">+</span><span class="fl">1.0e-8</span>)</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> entropy</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><span class="math inline">\(\mathbf{Z}\)</span>에 대한 분포를 임의로 만들어 엔트로피를 계산해본다.</p>
<div class="cell" data-outputid="a77da12e-9332-41d0-e5fe-61ad080c7da7">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dummy_q(<span class="op">*</span>Z):</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Z에 대해 확률분포를 계산하는 더미함수 </span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co">    여기서는 모든 Z에 균등한 함숫값을 계산 </span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="co">    gloval variables</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Zs : (K^N, N, K) </span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.</span> <span class="op">/</span> Zs.shape[<span class="dv">0</span>]</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 아무 의미없는 q(Z) 테스트</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>dummy_q(Zs[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>0.03125</code></pre>
</div>
</div>
<p>엔트로피를 계산하면 잘 계산되는 것을 확인할 수 있다.</p>
<div class="cell" data-outputid="7daad9cf-1d10-40ec-ca5d-3cce2cf7e533">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>entropy_Z(dummy_q)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>-3.4657355827997796</code></pre>
</div>
</div>
<p><span class="math inline">\(q(\mathbf{Z})\)</span>를 <span class="math inline">\(p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}})\)</span>로 제안받아 엔트로피를 계산해보자.</p>
<div class="cell" data-outputid="5c9adbf4-64ea-4135-87b9-e50714fdf530">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>p_Z_given_X_and_theta_old <span class="op">=</span> set_posterior_Z(X, theta_old)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>entropy_Z(p_Z_given_X_and_theta_old)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>-2.4126501017806823</code></pre>
</div>
</div>
<p>이제 부속이 모두 준비되었으므로 <span class="math inline">\(q(\mathbf{Z})\)</span>를 제안받아 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>를 계산하는 함수를 만든다. <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>는 로그가능도의 하한lower bound라는 의미로 ELBO(Evidence Lower BOund)라고 하기도 한다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Evidence Lower BOund, abbreviated as ELBO</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ELBO(q, theta) :</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co">    global variables</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="co">    X         : (N,D)</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Zs        : (K^N, N, K) </span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="co">    theta_old : (4,), (mu_1, mu_2, pi_1, pi_2)</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a><span class="co">    K</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    E <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> Z_i <span class="kw">in</span> Zs :</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>        E <span class="op">+=</span> q(Z_i)<span class="op">*</span>loglikelihood_XZ(theta, X, Z_i)</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> E <span class="op">-</span> entropy_Z(q) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>ELBO(q, theta)</code>를 사용하여 식(9.70)을 시각화해보기 위해 첫 번째로 <span class="math inline">\(q(\mathbf{Z})\)</span>를 <code>dummy_q()</code>로 두고 그림을 그려보자.</p>
<div class="cell" data-outputid="79be5d98-5b5a-472b-f037-6b96f0932b3f">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 제안분포를 dummy_q()로 선택하여 ELBO를 계산</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>l_q_theta_dummy <span class="op">=</span> ELBO(dummy_q, theta_old)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>ln_p_X_theta <span class="op">=</span> loglikelihood_X(theta_old, X)</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"l(q,theta)    : </span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(l_q_theta_dummy))</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"ln p(X|theta) : </span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(ln_p_X_theta))</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>margin <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a><span class="co"># ln p(X|theta_old)</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, <span class="dv">6</span>], [ln_p_X_theta]<span class="op">*</span><span class="dv">2</span>, <span class="st">'r'</span>, lw<span class="op">=</span><span class="st">'3'</span>)</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">3.8</span>, ln_p_X_theta<span class="op">-</span>margin, </span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>        <span class="vs">r"$\ln p( \mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">})$"</span>,  </span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a><span class="co"># L(q_dummy,theta_old)</span></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, <span class="dv">3</span>], [l_q_theta_dummy]<span class="op">*</span><span class="dv">2</span>, <span class="st">'b'</span>, lw<span class="op">=</span><span class="st">'3'</span>)</span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">0.8</span>, l_q_theta_dummy<span class="op">-</span>margin, </span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>        <span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q_{\text</span><span class="sc">{dummy}</span><span class="vs">}, \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">})$"</span>, </span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a><span class="co"># KL</span></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">0</span>, ln_p_X_theta<span class="op">+</span>margin, <span class="vs">r"$\text</span><span class="sc">{KL}</span><span class="vs">(q || p)$"</span>,  color<span class="op">=</span><span class="st">'g'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a>ax.arrow(<span class="fl">0.5</span>, l_q_theta_dummy, <span class="dv">0</span>, ln_p_X_theta<span class="op">-</span>l_q_theta_dummy, </span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a>         head_width<span class="op">=</span><span class="fl">0.1</span>, head_length<span class="op">=</span><span class="fl">0.2</span>, fc<span class="op">=</span><span class="st">'g'</span>, ec<span class="op">=</span><span class="st">'g'</span>, length_includes_head<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a>ax.arrow(<span class="fl">0.5</span>, ln_p_X_theta, <span class="dv">0</span>, l_q_theta_dummy<span class="op">-</span>ln_p_X_theta, </span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a>         head_width<span class="op">=</span><span class="fl">0.1</span>, head_length<span class="op">=</span><span class="fl">0.2</span>, fc<span class="op">=</span><span class="st">'g'</span>, ec<span class="op">=</span><span class="st">'g'</span>, length_includes_head<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">27</span>, <span class="op">-</span><span class="dv">20</span>])</span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true" tabindex="-1"></a>plt.xticks([])</span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>l(q,theta)    : -23.002070
ln p(X|theta) : -21.484619</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-36-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>현재 파라미터 <span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>에서 <code>dummy_q()</code>를 <span class="math inline">\(q(\mathbf{Z})\)</span>로 하여 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta}^{\text{old}})\)</span>값을 계산해보면 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta}^{\text{old}})\)</span> 보다 약간 작고 그 차이가 <span class="math inline">\(\text{KL}(q\,||\,p)\)</span>로 나타나는 것을 확인할 수 있다.</p>
<p>이제 <span class="math inline">\(q(\mathbf{Z})\)</span>를 <span class="math inline">\(\mathbf{Z}\)</span>에 대한 사후확률분포로 바꿔보자. <span class="math inline">\(q(\mathbf{Z}) = p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}})\)</span>로 설정한다.</p>
<div class="cell" data-outputid="fbba527e-eff7-45ad-a550-73f5ece259dc">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ELBO를 계산할 때 제안하는 q(Z)를 Z의 사후확률분포로 제안한다.</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>p_Z_given_X_and_theta_old <span class="op">=</span> set_posterior_Z(X, theta_old)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>l_q_theta <span class="op">=</span> ELBO(p_Z_given_X_and_theta_old, theta_old)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>ln_p_X_theta <span class="op">=</span> loglikelihood_X(theta_old, X)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"l(q,theta)    : </span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(l_q_theta))</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"ln p(X|theta) : </span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(ln_p_X_theta))</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="co"># ln p(X|theta_old)</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, <span class="dv">6</span>], [ln_p_X_theta]<span class="op">*</span><span class="dv">2</span>, <span class="st">'r'</span>, lw<span class="op">=</span><span class="st">'3'</span>)</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">3.8</span>, ln_p_X_theta<span class="op">-</span>margin, <span class="vs">r"$\ln p( \mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">})$"</span>,  </span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a><span class="co"># L(q(Z|X, theta_old),theta_old)</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, <span class="dv">3</span>], [l_q_theta]<span class="op">*</span><span class="dv">2</span>, <span class="st">'b'</span>, lw<span class="op">=</span><span class="st">'3'</span>)</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">0.8</span>, l_q_theta<span class="op">-</span>margin, <span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q(\mathbf</span><span class="sc">{Z}</span><span class="vs">\mid \mathbf</span><span class="sc">{X}</span><span class="vs">, \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">}), \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">})$"</span>, </span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>ax.arrow(<span class="fl">0.5</span>, l_q_theta_dummy, <span class="dv">0</span>, ln_p_X_theta<span class="op">-</span>l_q_theta_dummy, </span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>         head_width<span class="op">=</span><span class="fl">0.1</span>, head_length<span class="op">=</span><span class="fl">0.2</span>, fc<span class="op">=</span><span class="st">'b'</span>, ec<span class="op">=</span><span class="st">'b'</span>, length_includes_head<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a><span class="co"># L(q_dummy,theta_old)</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, <span class="dv">3</span>], [l_q_theta_dummy]<span class="op">*</span><span class="dv">2</span>, <span class="st">'b--'</span>, lw<span class="op">=</span><span class="st">'3'</span>)</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">0.8</span>, l_q_theta_dummy<span class="op">-</span>margin, <span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q_{\text</span><span class="sc">{dummy}</span><span class="vs">}, \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">})$"</span>, </span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a><span class="co"># KL</span></span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">0</span>, ln_p_X_theta<span class="op">+</span>margin, <span class="vs">r"$\text</span><span class="sc">{KL}</span><span class="vs">(q || p)=0$"</span>,  color<span class="op">=</span><span class="st">'g'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">27</span>, <span class="op">-</span><span class="dv">20</span>])</span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a>plt.xticks([])</span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>l(q,theta)    : -21.484619
ln p(X|theta) : -21.484619</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-37-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>예상대로 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta}^{\text{old}})= \ln p(\mathbf{X} \mid \boldsymbol{\theta}^{\text{old}})\)</span>가 되며 <span class="math inline">\(\text{KL}(q\,||\,p)\)</span>가 사라진다.</p>
<section id="mathcallq-boldsymboltheta와-완전-데이터-세트-로그가능도-평균-mathbbe_mathbfzln-pmathbfx-mathbfz-mid-boldsymboltheta의-관계" class="level3">
<h3 class="anchored" data-anchor-id="mathcallq-boldsymboltheta와-완전-데이터-세트-로그가능도-평균-mathbbe_mathbfzln-pmathbfx-mathbfz-mid-boldsymboltheta의-관계"><span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>와 완전 데이터 세트 로그가능도 평균 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}}[\ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})]\)</span>의 관계</h3>
<p>이쯤에서 지금까지 이야기한 완전 데이트 세트에 대한 로그 가능도 평균과 그것을 반복적으로 최대화 시키는 과정이 식(9.70)과 어떻게 연결되는지 알아보자.</p>
<p><span class="math inline">\(q(\mathbf{Z})\)</span>를 <span class="math inline">\(p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}})\)</span>로 설정하면 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>는 식(9.74)처럼 될 것이다.</p>
<p><span class="math display">\[
\begin{aligned}
\mathcal{L}(q, \boldsymbol{\theta})
&amp;= \sum_{\mathbf{Z}} p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}}) \ln p(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta}) - \sum_{\mathbf{Z}} p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}}) \ln p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}}) \\
&amp;=  \mathcal{Q}(\boldsymbol{\theta}, \boldsymbol{\theta}^{\text{old}}) + \text{const}
\end{aligned} \tag{9.74}
\]</span></p>
<p>놀랍게도 식(9.74)에서 첫 번째 항은 <span class="math inline">\(\mathcal{Q}(\boldsymbol{\theta}, \boldsymbol{\theta}^{\text{old}})\)</span> 또는 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}}[\ln(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})]\)</span>가 된다. 그리고 두 번째 항은 현재 파라미터 <span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>에만 의존하고 <span class="math inline">\(\boldsymbol{\theta}\)</span>와는 상관없는 상수항이다. 따라서 <span class="math inline">\(q(\mathbf{Z})\)</span>를 <span class="math inline">\(\mathbf{Z}\)</span>의 사후확률분포로 설정하고 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>을 계산하는 것이 결국 <span class="math inline">\(\mathbf{Z}\)</span>의 사후확률분포하에서 완전 데이터 세트의 로그가능도 평균을 구하는 것과 대등한 것이다.</p>
<p>결국 <span class="math inline">\(\mathcal{Q}(\boldsymbol{\theta}, \boldsymbol{\theta}^{\text{old}})\)</span> 또는 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}}[\ln(\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})]\)</span>를 <span class="math inline">\(\boldsymbol{\theta}\)</span>대해 최대화 하는 것이 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>를 최대화 하는 것이라는 사실을 알 수 있다.</p>
<p>방금까지 과정이 EM 알고리즘에서 기대값을 구성하는 단계인 Expectation 단계이다.</p>
<p>정리하면 우리는 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 최대화 하는 <span class="math inline">\(\boldsymbol{\theta}\)</span>를 찾고 싶은데 <span class="math inline">\(\ln(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 직접 최대화하는 것은 어려우니 <span class="math inline">\(\mathbf{Z}\)</span>의 사후확률을 도입하여 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>의 하한인 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>를 최대한 키워 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>와 동일하게 만들었다.</p>
<p>그리고 이때 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>는 완전 데이터 세트에 대한 가능도의 기댓값 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}}[\ln (\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})]\)</span>와 상수로 구성되기 때문에 결과적으로 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>를 최대화 시키는 것이 곧 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}}[\ln (\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})]\)</span>를 최대화 시키는 것을 알았다. 또 중요한 점은 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>이 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>의 하한이기 때문에 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>을 증가시키면 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>는 무조건 증가할 것이라는 점이다.</p>
<p><span class="math inline">\(\mathbb{E}_{\mathbf{Z}}[\ln (\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})]\)</span>를 최대화 시키는 것은 이미 3편에서 알아본 것과 같다. <span class="math inline">\(\gamma\)</span>를 구해 Expectation 단계를 수행한다. <span class="math inline">\(\gamma\)</span>를 구하는 과정이 곧 <span class="math inline">\(p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}})\)</span>를 제안하는 것임을 상기하자. 그렇게 제안된 <span class="math inline">\(p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}})\)</span>하에서 계산된 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}}[\ln (\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})]\)</span>를 직접 미분하여 얻은 식(29), (32)를 수행한다.</p>
<p>이 두 과정을 묶어 <code>EM_step()</code>이라는 함수로 만들자.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> EM_step() :</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="co">    gloval variables</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co">    X : (N,D)</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="co">    theta_old : (4,), (mu_1, mu_2, pi_1, pi_2)</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="co">    n_t</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    mu_old <span class="op">=</span> theta_old[:K<span class="op">*</span>D].reshape(K,D)</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    pi_old <span class="op">=</span> theta_old[<span class="op">-</span>K:]</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    Gamma <span class="op">=</span> np.array([ pi_old[k]<span class="op">*</span>binom.pmf(X, n_t, mu_old[k][<span class="dv">0</span>]) </span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(K) ]).transpose(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>).squeeze()</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    Gamma <span class="op">/=</span> Gamma.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>    Nk <span class="op">=</span> Gamma.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>    mu_new <span class="op">=</span> ((Gamma <span class="op">*</span> X).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>) <span class="op">/</span> (Nk<span class="op">*</span>n_t)).reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>    pi_new <span class="op">=</span> Nk <span class="op">/</span> N</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mu_new, pi_new</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>실제 <code>EM_step()</code>을 수행하고 새롭게 얻어진 파라미터를 <code>theta_new</code>로 설정한다.</p>
<div class="cell" data-outputid="ed02c9c8-c110-42be-c734-182ecc75d1d9">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>mu_new, pi_new <span class="op">=</span> EM_step()</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>theta_new <span class="op">=</span> np.hstack((mu_new.flatten(), pi_new))</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(theta_old)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(theta_new)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0.4 0.3 0.5 0.5]
[0.70729725 0.45725284 0.73085881 0.26914119]</code></pre>
</div>
</div>
<p>새롭게 계산된 파라미터 <span class="math inline">\(\boldsymbol{\theta}^{\text{new}}\)</span>에 의해 증가된 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>와 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 그려보자.</p>
<div class="cell" data-outputid="9c61ef56-2280-49b3-e3dd-06a6d3ba6bd0">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ELBO를 계산할 때 제안하는 q(Z)를 Z의 사후확률분포로 제안한다.</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="co"># theta_old가 theta_new로 업데이트 되었으나 사후분포를 구성할 때 사용된</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="co"># theta_old는 고정된 상태이다.</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>p_Z_given_X_and_theta_old <span class="op">=</span> set_posterior_Z(X, theta_old)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>l_q_theta_new <span class="op">=</span> ELBO(p_Z_given_X_and_theta_old, theta_new)</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>ln_p_X_theta_new <span class="op">=</span> loglikelihood_X(theta_new, X)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"l(q,theta)    : </span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(l_q_theta_new))</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"ln p(X|theta) : </span><span class="sc">{:.6f}</span><span class="st">"</span>.<span class="bu">format</span>(ln_p_X_theta))</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a><span class="co"># ln p(X|theta_new)</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, <span class="dv">6</span>], [ln_p_X_theta_new]<span class="op">*</span><span class="dv">2</span>, <span class="st">'r'</span>, lw<span class="op">=</span><span class="st">'3'</span>)</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">3.8</span>, ln_p_X_theta_new<span class="op">-</span>margin<span class="op">*</span><span class="dv">2</span>, <span class="vs">r"$\ln p( \mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \boldsymbol{\theta}^{\text</span><span class="sc">{new}</span><span class="vs">})$"</span>,  </span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>ax.arrow(<span class="fl">3.5</span>, ln_p_X_theta, <span class="dv">0</span>, ln_p_X_theta_new<span class="op">-</span>ln_p_X_theta, </span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>         head_width<span class="op">=</span><span class="fl">0.1</span>, head_length<span class="op">=</span><span class="fl">0.2</span>, fc<span class="op">=</span><span class="st">'r'</span>, ec<span class="op">=</span><span class="st">'r'</span>, length_includes_head<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a><span class="co"># ln p(X|theta_old)</span></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">3</span>, <span class="dv">6</span>], [ln_p_X_theta]<span class="op">*</span><span class="dv">2</span>, <span class="st">'r--'</span>, lw<span class="op">=</span><span class="st">'3'</span>)</span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">3.8</span>, ln_p_X_theta<span class="op">-</span>margin<span class="op">*</span><span class="dv">2</span>, <span class="vs">r"$\ln p( \mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">})$"</span>,  </span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a><span class="co"># L(q(Z|X, theta_old),theta_new)</span></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, <span class="dv">3</span>], [l_q_theta_new]<span class="op">*</span><span class="dv">2</span>, <span class="st">'b'</span>, lw<span class="op">=</span><span class="st">'3'</span>)</span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">0.8</span>, l_q_theta_new<span class="op">-</span>margin<span class="op">*</span><span class="dv">2</span>, <span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q(\mathbf</span><span class="sc">{Z}</span><span class="vs"> \mid \mathbf</span><span class="sc">{X}</span><span class="vs">, \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">}), \boldsymbol{\theta}^{\text</span><span class="sc">{new}</span><span class="vs">})$"</span>, </span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>ax.arrow(<span class="fl">0.5</span>, l_q_theta, <span class="dv">0</span>, l_q_theta_new<span class="op">-</span>l_q_theta, </span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>         head_width<span class="op">=</span><span class="fl">0.1</span>, head_length<span class="op">=</span><span class="fl">0.2</span>, fc<span class="op">=</span><span class="st">'b'</span>, ec<span class="op">=</span><span class="st">'b'</span>, length_includes_head<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a><span class="co"># L(q(Z|X, theta_old),theta_old)</span></span>
<span id="cb63-34"><a href="#cb63-34" aria-hidden="true" tabindex="-1"></a>ax.plot([<span class="dv">0</span>, <span class="dv">3</span>], [l_q_theta]<span class="op">*</span><span class="dv">2</span>, <span class="st">'b--'</span>, lw<span class="op">=</span><span class="st">'3'</span>)</span>
<span id="cb63-35"><a href="#cb63-35" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">0.8</span>, l_q_theta<span class="op">-</span>margin<span class="op">*</span><span class="dv">2</span>, <span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q(\mathbf</span><span class="sc">{Z}</span><span class="vs"> \mid \mathbf</span><span class="sc">{X}</span><span class="vs">, \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">}), \boldsymbol{\theta}^{\text</span><span class="sc">{old}</span><span class="vs">})$"</span>, </span>
<span id="cb63-36"><a href="#cb63-36" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'b'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb63-37"><a href="#cb63-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-38"><a href="#cb63-38" aria-hidden="true" tabindex="-1"></a><span class="co"># KL</span></span>
<span id="cb63-39"><a href="#cb63-39" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">0</span>, ln_p_X_theta_new<span class="op">+</span>margin, <span class="vs">r"$\text</span><span class="sc">{KL}</span><span class="vs">(q || p)$"</span>,  color<span class="op">=</span><span class="st">'g'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb63-40"><a href="#cb63-40" aria-hidden="true" tabindex="-1"></a>ax.arrow(<span class="fl">0.5</span>, l_q_theta_new, <span class="dv">0</span>, ln_p_X_theta_new<span class="op">-</span>l_q_theta_new, </span>
<span id="cb63-41"><a href="#cb63-41" aria-hidden="true" tabindex="-1"></a>         head_width<span class="op">=</span><span class="fl">0.1</span>, head_length<span class="op">=</span><span class="fl">0.2</span>, fc<span class="op">=</span><span class="st">'g'</span>, ec<span class="op">=</span><span class="st">'g'</span>, length_includes_head<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb63-42"><a href="#cb63-42" aria-hidden="true" tabindex="-1"></a>ax.arrow(<span class="fl">0.5</span>, ln_p_X_theta_new, <span class="dv">0</span>, l_q_theta_new<span class="op">-</span>ln_p_X_theta_new, </span>
<span id="cb63-43"><a href="#cb63-43" aria-hidden="true" tabindex="-1"></a>         head_width<span class="op">=</span><span class="fl">0.1</span>, head_length<span class="op">=</span><span class="fl">0.2</span>, fc<span class="op">=</span><span class="st">'g'</span>, ec<span class="op">=</span><span class="st">'g'</span>, length_includes_head<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb63-44"><a href="#cb63-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-45"><a href="#cb63-45" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">23</span>, <span class="op">-</span><span class="dv">11</span>])</span>
<span id="cb63-46"><a href="#cb63-46" aria-hidden="true" tabindex="-1"></a>plt.xticks([])</span>
<span id="cb63-47"><a href="#cb63-47" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb63-48"><a href="#cb63-48" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>l(q,theta)    : -13.141270
ln p(X|theta) : -21.484619</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-40-output-2.png" class="img-fluid"></p>
</div>
</div>
<p><span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>에서 <span class="math inline">\(\boldsymbol{\theta}^{\text{new}}\)</span>로 파라미터가 조정되면서 두 함수 모두 점선 위치에서 증가하였다. 증가된 정도를 보면 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta}^{\text{new}})\)</span>가 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta}^{\text{new}})\)</span>보다 조금 더 증가되었다. 그 이유는 <span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>에서 <span class="math inline">\(\boldsymbol{\theta}^{\text{new}}\)</span> 변경되면서 현재 파라미터 상태에서 <span class="math inline">\(p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{new}})\)</span>는 <span class="math inline">\(p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{old}})\)</span>와 달라졌으며 그 결과 <span class="math inline">\(KL(q \,||\, p)\)</span>는 다음과 같이 0이 아니기 때문이다.</p>
<p><span class="math display">\[
KL(q \,||\, p) = - \sum_{\mathbf{Z}} p(\mathbf{Z} \mid \mathbf{X},\boldsymbol{\theta}^{\text{old}}) \ln \frac{p(\mathbf{Z} \mid \mathbf{X},\boldsymbol{\theta}^{\text{new}})}{ p(\mathbf{Z} \mid \mathbf{X},\boldsymbol{\theta}^{\text{old}}) } \neq 0
\]</span></p>
<p>이 한번의 반복으로 원래 <span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>보다 더 큰 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span> 함숫값을 주는 <span class="math inline">\(\boldsymbol{\theta}^{\text{new}}\)</span>를 찾아내게 되었다. 이 과정이 Maximization 과정이다.</p>
<p>이제 <span class="math inline">\(q(\mathbf{Z})\)</span>를 <span class="math inline">\(p(\mathbf{Z} \mid \mathbf{X}, \boldsymbol{\theta}^{\text{new}})\)</span>로 재설정하는 Expectation 과정을 반복하면 두 번째 그림 상태로 돌아가게 된다. 여기서 다시 Maximization 과정을 수행하여 조금 더 큰 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span> 함숫값을 주는 <span class="math inline">\(\boldsymbol{\theta}^{\text{new}}\)</span>를 구할 수 있다. 이 과정을 반복하는 동안 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>는 절대 줄어들지 않으며 결과적으로 <span class="math inline">\(\mathbb{E}_{\mathbf{Z}}[\ln (\mathbf{X}, \mathbf{Z} \mid \boldsymbol{\theta})]\)</span>를 최대화하는 과정을 반복하면서 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 최대화하게 되는 것이다.</p>
<p>이것으로 평균을 최대화 시키는 방법이 왜 유효하고 그것의 반복이 왜 수렴하는지 알 수 있게 되었다.</p>
</section>
</section>
<section id="em-알고리즘-시각화" class="level2">
<h2 class="anchored" data-anchor-id="em-알고리즘-시각화">EM 알고리즘 시각화</h2>
<p>지금까지 아주 길게 완전 데이트 세트 가능도 평균의 최대화를 반복하는 과정이 <span class="math inline">\(\ln(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 최대화시키는 이유에 대해서 알아보았다. 이제 실제 우리가 설정한 문제에서 어떤 식으로 최대화가 일어나고 있는지 시각화하면서 이 길고 지루한 과정을 마무리해보자.</p>
<p>우리가 다루고 있는 문제에서 구하고자 하는 파라미터는 총 4개이므로 이 모든 파라미터가 최적화되는 과정을 시각화 할 수 없다. 그러므로 <span class="math inline">\(\boldsymbol{\theta}\)</span>에서 <span class="math inline">\(\mu_1\)</span>에 대해서만 <span class="math inline">\(\mathcal{L}(q, \boldsymbol{\theta})\)</span>와 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>의 관계를 시각화 해보자.</p>
<p>현재 파라미터 상태를 적당히 설정한다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>mu_old <span class="op">=</span> np.array([[<span class="fl">0.6</span>],[<span class="fl">0.45</span>]])</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>pi_old <span class="op">=</span> np.array([<span class="fl">0.6</span>, <span class="fl">0.4</span>])</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>theta_old <span class="op">=</span> np.hstack((mu_old.flatten(), pi_old))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>이전에 만들어 놓은 <code>loglikelihood_X()</code>를 이용해서 <span class="math inline">\(\mu_1\)</span>만을 변수로 하는 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 만든다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loglikelihood_X_mu1(mu_1, X):</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loglikelihood_X(np.array([mu_1, <span class="fl">0.45</span>, <span class="fl">0.6</span>, <span class="fl">0.4</span>]), X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>이제 <span class="math inline">\(\mu_1\)</span>에 따른 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>를 그려본다. 우리 목적은 국부적으로 <span class="math inline">\(\ln p(\mathbf{X} \mid \boldsymbol{\theta})\)</span>가 가장 높은 곳을 찾아가는 것이다.</p>
<div class="cell" data-outputid="fd54060c-92d5-4204-b509-1f0ed4f4e3fb">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>mus <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ln( p(X|theta) )</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>loglikelihood_X_by_mu1 <span class="op">=</span> np.array([ loglikelihood_X_mu1(mu,  X) </span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>                                    <span class="cf">for</span> mu <span class="kw">in</span> mus ])</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, loglikelihood_X_by_mu1, lw<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="vs">r"$\ln p(\mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \mu_1)$"</span>)</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">23</span>, <span class="op">-</span><span class="dv">10</span>])</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r'$\mu_1$'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-43-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>그림을 보면 0.8x 정도에서 최대점이 형성되는 것을 알 수 있다.</p>
<p>완전 데이터 집합의 로그가능도 평균도 <span class="math inline">\(\mu_1\)</span>만의 함수로 다시 만든다.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> E_Z_loglikelihood_XZ_mu1(mu_1, X):</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># mu_1을 제외한 나머지 파라미터들은 이미 최적화된 것으로 가정하고 고정</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> E_Z_loglikelihood_XZ(np.array([mu_1, <span class="fl">0.45</span>, <span class="fl">0.6</span>, <span class="fl">0.4</span>]), X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>이제 현재 <span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>를 조건으로 하는 사후확률분포를 이용하여 전체 <span class="math inline">\(\mu_1\)</span>에 대해서 <span class="math inline">\(\mathcal{L}(q, \mu_1)\)</span>을 그려본다. 이때 <span class="math inline">\(\ln p(\mathbf{X} \mid \mu_1)\)</span>도 함께 그려 상황을 확인해보자.</p>
<div class="cell" data-outputid="c2fd905a-0cad-4f60-8813-a9161c80443d">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>mus <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 현재 파라미터로 Z의 사후확률 q(Z|X,mu_1^{old})를 세팅한다.</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>p_Z_given_X_and_theta_old <span class="op">=</span> set_posterior_Z(X, theta_old)</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="co"># L(q,mu_1)를 mu_1에 대해서 다시 그린다.</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>l_q_theta <span class="op">=</span> np.array([ E_Z_loglikelihood_XZ_mu1(mu, X) </span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>                        <span class="op">-</span> entropy_Z(p_Z_given_X_and_theta_old) <span class="cf">for</span> mu <span class="kw">in</span> mus ])</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 현재 \mu_1^{old}에서 L(q,mu_1) 값을 계산한다.</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>l_q_theta_0 <span class="op">=</span> E_Z_loglikelihood_XZ_mu1(mu_old[<span class="dv">0</span>,<span class="dv">0</span>], X) <span class="op">\</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">-</span> entropy_Z(p_Z_given_X_and_theta_old) </span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, loglikelihood_X_by_mu1, lw<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="vs">r"$\ln p(\mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \mu_1)$"</span>)</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, l_q_theta, label<span class="op">=</span><span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q, \mu_1)$"</span>)</span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>ax.plot([mu_old[<span class="dv">0</span>,<span class="dv">0</span>], mu_old[<span class="dv">0</span>,<span class="dv">0</span>]], [<span class="op">-</span><span class="dv">23</span>,<span class="op">-</span><span class="dv">10</span>], <span class="st">'k--'</span>)</span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>ax.plot(mu_old[<span class="dv">0</span>,<span class="dv">0</span>], l_q_theta_0, <span class="st">'bo'</span>)</span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">23</span>, <span class="op">-</span><span class="dv">10</span>])</span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r'$\mu_1$'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-45-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>그림에서 확인할 수 있듯이 현재 파리미터에서 <span class="math inline">\(\mathcal{L}(q, \mu_1^{\text{old}}=0.6)\)</span>과 <span class="math inline">\(\ln p(\mathbf{X} \mid \mu^{\text{old}}_1=0.6)\)</span>가 같아지는 모습을 확인할 수 있다. 이제 이 상태에서 EM 스탭을 한번 반복한다.</p>
<div class="cell" data-outputid="823cdd38-9b91-4a2b-a6b5-f0c81aedb532">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co"># EM_step으로 새로운 파라미터를 얻는다.</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>mu_new, pi_new <span class="op">=</span> EM_step()</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 업데이트된 mu_1^{new}에서 L(q,mu_1) 값을 계산한다.</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>max_l_q_theta <span class="op">=</span> E_Z_loglikelihood_XZ_mu1(mu_new[<span class="dv">0</span>,<span class="dv">0</span>], X) <span class="op">\</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">-</span> entropy_Z(p_Z_given_X_and_theta_old) </span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, loglikelihood_X_by_mu1, lw<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="vs">r"$\ln p(\mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \mu_1)$"</span>)</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, l_q_theta, label<span class="op">=</span><span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q, \mu_1)$"</span>)</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>ax.plot([mu_new[<span class="dv">0</span>,<span class="dv">0</span>], mu_new[<span class="dv">0</span>,<span class="dv">0</span>]], [<span class="op">-</span><span class="dv">23</span>,<span class="op">-</span><span class="dv">10</span>], <span class="st">'k--'</span>)</span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>ax.plot(mu_new[<span class="dv">0</span>,<span class="dv">0</span>], max_l_q_theta, <span class="st">'ro'</span>)</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>ax.plot(mu_old[<span class="dv">0</span>,<span class="dv">0</span>], l_q_theta_0, <span class="st">'bo'</span>)</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">23</span>, <span class="op">-</span><span class="dv">10</span>])</span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r'$\mu_1$'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-46-output-1.png" class="img-fluid"></p>
</div>
</div>
<p><code>EM_step()</code> 결과 <span class="math inline">\(\mu_1^{\text{old}}\)</span>가 <span class="math inline">\(\mathcal{L}(q, \mu_1)\)</span>의 최대점으로 이동한 것을 확인할 수 있다. 파란 점보다 빨간 점이 <span class="math inline">\(\ln p(\mathbf{X} \mid \mu_1)\)</span>의 최대점에 조금 더 가까워졌다. 새롭게 구해진 파라미터를 <span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>로 업데이트하고 <span class="math inline">\(\boldsymbol{\theta}^{\text{old}}\)</span>를 조건으로 다시 <span class="math inline">\(\mathbf{Z}\)</span>의 사후확률분포를 계산한다.</p>
<div class="cell" data-outputid="17c37762-8c5f-4f87-df79-78eb98e93a69">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>mu_old <span class="op">=</span> mu_new</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>pi_old <span class="op">=</span> pi_new</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>theta_old <span class="op">=</span> np.hstack((mu_old.flatten(), pi_old))</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 현재 파라미터로 Z의 사후확률을 세팅한다.</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>p_Z_given_X_and_theta_old <span class="op">=</span> set_posterior_Z(X, theta_old)</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mu_old)</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pi_old)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0.7428154 ]
 [0.43070022]]
[0.67058506 0.32941494]</code></pre>
</div>
</div>
<p>새롭게 구성된 사후확률하에서 <span class="math inline">\(\mathcal{L}(q, \mu_1)\)</span>을 다시 그려보면 <span class="math inline">\(\mu_1^{\text{old}}=0.743\)</span>에서 <span class="math inline">\(\ln p(\mathbf{X} \mid \mu_1)\)</span>과 접할 것이다.</p>
<div class="cell" data-outputid="f1938808-8ce8-4c0e-ee4f-6e6bc295d797">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>l_q_theta <span class="op">=</span> np.array([ E_Z_loglikelihood_XZ_mu1(mu, X) </span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span> entropy_Z(p_Z_given_X_and_theta_old) <span class="cf">for</span> mu <span class="kw">in</span> mus ])</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>l_q_theta_0 <span class="op">=</span> E_Z_loglikelihood_XZ_mu1(mu_old[<span class="dv">0</span>,<span class="dv">0</span>], X) <span class="op">\</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>                <span class="op">-</span> entropy_Z(p_Z_given_X_and_theta_old) </span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, loglikelihood_X_by_mu1, lw<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="vs">r"$\ln p(\mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \mu_1)$"</span>)</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, l_q_theta, label<span class="op">=</span><span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q, \mu_1)$"</span>)</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>ax.plot([mu_old[<span class="dv">0</span>,<span class="dv">0</span>], mu_old[<span class="dv">0</span>,<span class="dv">0</span>]], [<span class="op">-</span><span class="dv">23</span>,<span class="op">-</span><span class="dv">10</span>], <span class="st">'k--'</span>)</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>ax.plot(mu_old[<span class="dv">0</span>,<span class="dv">0</span>], l_q_theta_0, <span class="st">'bo'</span>)</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">23</span>, <span class="op">-</span><span class="dv">10</span>])</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r'$\mu_1$'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-48-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>예상대로 새롭게 구성된 <span class="math inline">\(\mathcal{L}(q, \mu_1)\)</span>이 <span class="math inline">\(\mu_1=0.743\)</span>에서 접하는 것을 확인할 수 있다. 이제 다시 <code>EM_step()</code>를 실행한다.</p>
<div class="cell" data-outputid="016c1f25-0371-4d1c-d467-ab22ee4069f8">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>mu_new, pi_new <span class="op">=</span> EM_step()</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>max_l_q_theta <span class="op">=</span> E_Z_loglikelihood_XZ_mu1(mu_new[<span class="dv">0</span>,<span class="dv">0</span>], X) <span class="op">\</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>                  <span class="op">-</span> entropy_Z(p_Z_given_X_and_theta_old)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, loglikelihood_X_by_mu1, lw<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="vs">r"$\ln p(\mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \mu_1)$"</span>)</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, l_q_theta, label<span class="op">=</span><span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q, \mu_1)$"</span>)</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>ax.plot([mu_new[<span class="dv">0</span>,<span class="dv">0</span>], mu_new[<span class="dv">0</span>,<span class="dv">0</span>]], [<span class="op">-</span><span class="dv">23</span>,<span class="op">-</span><span class="dv">10</span>], <span class="st">'k--'</span>)</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>ax.plot(mu_new[<span class="dv">0</span>,<span class="dv">0</span>], max_l_q_theta, <span class="st">'ro'</span>)</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>ax.plot(mu_old[<span class="dv">0</span>,<span class="dv">0</span>], l_q_theta_0, <span class="st">'bo'</span>)</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">23</span>, <span class="op">-</span><span class="dv">10</span>])</span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r'$\mu_1$'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-49-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>다시 <span class="math inline">\(\mathcal{L}(q, \mu_1)\)</span>의 최대값으로 파라미터가 업데이트 된다. 이런 과정을 계속 반복하면서 <span class="math inline">\(\ln p(\mathbf{X} \mid \mu_1)\)</span>의 국부 최대점으로 수렴하게 되는 것이다.</p>
<div class="cell" data-outputid="c7c8cada-c6b4-43f0-d5d0-6efb9ed76088">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>mu_old <span class="op">=</span> mu_new</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>pi_old <span class="op">=</span> pi_new</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>theta_old <span class="op">=</span> np.hstack((mu_old.flatten(), pi_old))</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 현재 파라미터로 Z의 사후확률을 세팅한다.</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>p_Z_given_X_and_theta_old <span class="op">=</span> set_posterior_Z(X, theta_old)</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mu_old)</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pi_old)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0.81242457]
 [0.37383545]]
[0.60686538 0.39313462]</code></pre>
</div>
</div>
<div class="cell" data-outputid="39eda3dc-3b99-45f1-e14f-da154f44d792">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>l_q_theta <span class="op">=</span> np.array([ E_Z_loglikelihood_XZ_mu1(mu, X) </span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-</span> entropy_Z(p_Z_given_X_and_theta_old) <span class="cf">for</span> mu <span class="kw">in</span> mus ])</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>l_q_theta_0 <span class="op">=</span> E_Z_loglikelihood_XZ_mu1(mu_old[<span class="dv">0</span>,<span class="dv">0</span>], X) <span class="op">\</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>                <span class="op">-</span> entropy_Z(p_Z_given_X_and_theta_old) </span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, loglikelihood_X_by_mu1, lw<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="vs">r"$\ln p(\mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \mu_1)$"</span>)</span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, l_q_theta, label<span class="op">=</span><span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q, \mu_1)$"</span>)</span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>ax.plot([mu_old[<span class="dv">0</span>,<span class="dv">0</span>], mu_old[<span class="dv">0</span>,<span class="dv">0</span>]], [<span class="op">-</span><span class="dv">23</span>,<span class="op">-</span><span class="dv">10</span>], <span class="st">'k--'</span>)</span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>ax.plot(mu_old[<span class="dv">0</span>,<span class="dv">0</span>], l_q_theta_0, <span class="st">'bo'</span>)</span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">23</span>, <span class="op">-</span><span class="dv">10</span>])</span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r'$\mu_1$'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-51-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-outputid="eaaa0986-2bb0-46c8-9810-6b55272043a7">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>mu_new, pi_new <span class="op">=</span> EM_step()</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>max_l_q_theta <span class="op">=</span> E_Z_loglikelihood_XZ_mu1(mu_new[<span class="dv">0</span>,<span class="dv">0</span>], X) <span class="op">\</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>                  <span class="op">-</span> entropy_Z(p_Z_given_X_and_theta_old) </span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, loglikelihood_X_by_mu1, lw<span class="op">=</span><span class="dv">2</span>, </span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="vs">r"$\ln p(\mathbf</span><span class="sc">{X}</span><span class="vs"> \mid \mu_1)$"</span>)</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>ax.plot(mus, l_q_theta, label<span class="op">=</span><span class="vs">r"$\mathcal</span><span class="sc">{L}</span><span class="vs">(q, \mu_1)$"</span>)</span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>ax.plot([mu_new[<span class="dv">0</span>,<span class="dv">0</span>], mu_new[<span class="dv">0</span>,<span class="dv">0</span>]], [<span class="op">-</span><span class="dv">23</span>,<span class="op">-</span><span class="dv">10</span>], <span class="st">'k--'</span>)</span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>ax.plot(mu_new[<span class="dv">0</span>,<span class="dv">0</span>], max_l_q_theta, <span class="st">'ro'</span>)</span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>ax.plot(mu_old[<span class="dv">0</span>,<span class="dv">0</span>], l_q_theta_0, <span class="st">'bo'</span>)</span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="op">-</span><span class="dv">23</span>, <span class="op">-</span><span class="dv">10</span>])</span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r'$\mu_1$'</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="em_algorithm_files/figure-html/cell-52-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>이렇게 나름 복잡하다면 복잡한 EM 알고리즘을 알아봤다. 소설처럼 술술 읽히는 글은 아닐지라도 EM 알고리즘을 어렴풋이 이해하고 있는 분들께는 나름 도움이 될 것이라는 믿음으로 글을 마무리한다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>